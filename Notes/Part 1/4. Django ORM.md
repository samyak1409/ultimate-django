## Django ORM

Docs: https://docs.djangoproject.com/en/5.2/topics/db/queries

### What problem does it solves?

We needed to do:

```py
sql = 'SELECT * FROM product'
result = execute(sql)
for row in result:
    product = Product()
    product.title = row['title']
    produce.price = row['price']
```

[Object-Relational Mapping](https://en.wikipedia.org/wiki/Object–relational_mapping)

Maps the object with the relational records (ORM translates the code to SQL at runtime):

```py
products = Product.objects.all()
```

> So do we no longer need to know SQL?  
> No, for complex tasks, we may still need to write queries by ourselves. E.g., ORM could produce inefficient SQL for complex tasks.

<br>

Note that ORMs are bit slow compared to directly querying the DB due to the obvious reason. But, ORMs helps to ship the app fast. And for most apps, the slow speed is negligible.

> "Premature optimization is the root of all evils."  
> \- Donald Knuth

## Managers and QuerySets

`ModelName.objects` is a `Manager` object which is basically an interface to the DB.  
It has methods to query the DB like `.all()`, `.get()`, `.filter()`, `.exclude()`. (These are the most used ones.)

https://docs.djangoproject.com/en/5.2/topics/db/queries/#retrieving-objects

`all`, `filter`, `exclude` returns a [QuerySet](https://docs.djangoproject.com/en/5.2/ref/models/querysets/#django.db.models.query.QuerySet) object.  
`get` returns the single object directly.

### [`QuerySet`s are lazy](https://docs.djangoproject.com/en/5.2/topics/db/queries/#querysets-are-lazy)

`QuerySet` is not actually a `set` as the name might indicate, it actually works just like an `Iterator` object.  
Meaning, it evaluates the result (execute DB query) on the go when we actually access the value.

Why?  
Because we frequently chain methods like following in order to mimic a complex/nested query:

```py
qs = ModelName.objects.all()
print(qs.filter().order_by().get())
```

If `QuerySet` were not lazy, then first query would form, result will return (all millions of data) in the memory, and then next query will apply on that.  
That's very inefficient.
Hence, what actually happens is Django forms the actual SQL query using all the chained methods, and directly forms the actual complex/nested query that we were meant.

## Retrieving Objects

Check the code in `playground.views.home`.

<br>

Fun-fact (researched on my own):  
(Background: As we already know `get` is for a single object only. If the query returns multiple (or zero) objects, then Django raises error.)
But when you do `ModelName.objects.get(column_name=1)`, Django adds a `LIMIT 21` in the SQL query that it executes, which looks weird.

Check the code here: https://github.com/django/django/blame/main/django/db/models/query.py  
Here's the commit in which this was added: https://github.com/django/django/commit/330638b89f14e1fb06e9d313ccc9768ae167c53f

Reason:
`21` is a random/arbitrary number, and it's there as a safeguard if someone mistakenly get a result that returns millions of records, that can freeze the app.  
Hence, Django only fetches at most 21 records, and then raise `MultipleObjectsReturned` exception. (Meaning Django could've just used `LIMIT 2` to verify, but they probably did it for fun.)

## Filtering Objects

Field lookup types: https://docs.djangoproject.com/en/5.2/ref/models/querysets/#field-lookups

Methods: `filter()`, `exclude()`, `get()`

Syntax:

```py
field_name__lookuptype=value
```

E.g.:

```py
unit_price__gt=20
```

We can also use `__` for nested lookups, e.g., `product` is a foreign key (of any type), and the `Product` table has a field `collection`, we can do: `product__collection`.

Check the code in `playground.views.home`.

<br>

**Note:**

Django Debug Toolbar's `Sel` & `Expl` buttons are not visible for some queries. Why?

> **The code responsible for showing the "sel" button checks both if the query is a SELECT and if it uses parameters.** If your queries don’t use parameters (values are inlined), the button won’t be shown, even if the query returns results.
>
> If you want the "sel" button for those queries, ensure they are parameterized at the SQL level (not just at the Python/Django level). This depends on how Django ORM translates your filters to SQL. **Some simple filters may not use parameters.**
>
> \- [GitHub Copilot](https://github.com/copilot/share/4a5a12ba-0000-8447-a911-0e41802a013e)

Here's the code responsible for this:

- [debug_toolbar/templates/debug_toolbar/panels/sql.html](https://github.com/django-commons/django-debug-toolbar/blob/afd5e7e0be1632abf26fae6d31e3aafec4be788f/debug_toolbar/templates/debug_toolbar/panels/sql.html#L77)
- [debug_toolbar/panels/sql/tracking.py](https://github.com/django-commons/django-debug-toolbar/blob/afd5e7e0be1632abf26fae6d31e3aafec4be788f/debug_toolbar/panels/sql/tracking.py#L149)

(Researched by me.)

## Complex Lookups Using Q Objects

> `~` (`NOT`), `|` (`OR`), `&` (`AND`), `^` (`XOR`)

Check the code in `playground.views.home`.

https://docs.djangoproject.com/en/5.2/ref/models/querysets/#q-objects

## Referencing Fields using F Objects

> Reference fields.

Check the code in `playground.views.home`.

https://docs.djangoproject.com/en/5.2/ref/models/expressions/#django.db.models.F

## Sorting

> `order_by()`, `earliest()`, `latest()`

Check the code in `playground.views.home`.

## Limiting Results

> Slicing: `QuerySet[OFFSET:OFFSET+LIMIT]`

Check the code in `playground.views.home`.

## Selecting Fields to Query

> `values()`, `values_list()`

> "The people who made Django prefer to put all the SQL-affecting methods first, followed (optionally) by any output-affecting methods (such as `values()`), but it doesn’t really matter."

Check the code in `playground.views.home`.

https://docs.djangoproject.com/en/5.2/ref/models/querysets/#values

## Deferring Fields

> `only()`, `defer()`

**Imp:** Pay attention to `object.attr` usages. Check the code in `playground.views.home`.

## Selecting Related Objects

> `select_related()`: `INNER JOIN` in a single query; used in case of `OneToOneField` & `ForeignKey`
>
> `prefetch_related()`: Separate query + Python join (see the details below); used in case of `ManyToManyField` & reverse `ForeignKey` (i.e., when accessing the `_set` on a model)

Solves classic **N+1 query problem**:

- https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping
- https://planetscale.com/blog/what-is-n-1-query-problem-and-how-to-solve-it

> Note:  
> Use `select_related` or `prefetch_related` when you plan to access related objects via ORM attributes in Python after the query.  
> For queries that only retrieve raw fields from related tables (e.g., using .values(), .annotate()), Django generates the necessary SQL joins for those fields automatically.

Check the code and **important points** in `playground.views.home`.

<br>

### `prefetch_related()` is not straight-forward. Its implementation is smart and optimized.

> [Researched entirely by me.]

```python
Product.objects.prefetch_related('promotions').all()
```

Should generate following, right:

```sql
SELECT *
FROM store_product p
INNER JOIN store_product_promotions j
ON p.id = j.product_id
```

> See [example](https://github.com/samyak1409/ultimate-django/blob/main/Notes/Part%201/2.%20Building%20a%20Data%20Model.md#a-concrete-example-students--courses).

But, it generates:

```sql
SELECT "store_product"."id",
       "store_product"."title",
       "store_product"."slug",
       "store_product"."description",
       "store_product"."unit_price",
       "store_product"."inventory",
       "store_product"."last_update",
       "store_product"."collection_id"
  FROM "store_product";

SELECT •••
FROM "store_promotion"
INNER JOIN "store_product_promotions"
ON ("store_promotion"."id" = "store_product_promotions"."promotion_id")
WHERE "store_product_promotions"."product_id" IN (<ids from above query>)
```

Doesn't appear to make sense, right? But:

Django's `prefetch_related` uses two queries because it is more efficient than a single `JOIN`. It avoids the primary performance bottleneck: **duplicating the main table's data**. It achieves this by fetching the main objects first, then fetching all related objects in a second targeted query, and finally stitching the data together in Python. This approach minimizes data transfer and simplifies object creation.

For explanation, read the last responses in the chats:

- https://g.co/gemini/share/b32a073255ed
- https://chatgpt.com/share/687aa433-4588-800a-a83c-58d5ed27e5e8

## Aggregating Objects

> Summarizing data like `Avg`, `Count`, `Max`, `Min`, `Sum`

Check the code in `playground.views.home`.

Aggregation functions: https://docs.djangoproject.com/en/5.2/ref/models/querysets/#aggregation-functions

Cheat sheet: https://docs.djangoproject.com/en/5.2/topics/db/aggregation/#cheat-sheet

## Annotating Objects

> Translates to adding a custom/computed column in SQL while selecting.

Check the code in `playground.views.home`.

https://docs.djangoproject.com/en/5.2/ref/models/querysets/#annotate

### Django Field vs. Lookup Conflict

> [Researched by me.]

If a lookup type name (like `count`) is the same as a field name, **Django will always treat it as the field name**. To use the `Count` aggregate function for counting related objects, you must explicitly use `annotate()` with `from django.db.models import Count`.

- `filter(product__count__gt=5)`: Filters based on the **value of the `count` field** on the `Product` model.
- `annotate(c=Count('product')).filter(c__gt=5)`: Filters based on the **number of related `product` objects**.

Read: https://g.co/gemini/share/d8c6d112540b

## Calling Database Functions

> We can use the generic `Func()` class or dedicated helper classes for common functions.

### When to Use What:

| Use Case                        | Recommended Approach         |
| ------------------------------- | ---------------------------- |
| Common SQL function             | Use dedicated function class |
| Custom/unsupported SQL function | Use `Func()` manually        |

Check the code in `playground.views.home`.

https://docs.djangoproject.com/en/5.2/ref/models/database-functions

## Grouping Data

If we want to see number of orders each customer has placed:

`Customer.objects.annotate(Count("order_set"))` - `FieldError`

`Customer.objects.annotate(Count("order"))` - Correct

Why?

> (Researched by me.)

`order_set` is a Python-level manager accessor  
`order` is database-level relationship name

Read here:

- https://www.perplexity.ai/search/why-does-instead-of-default-na-cjt6YqS9QcCH.9KyTBLSCg
- https://g.co/gemini/share/be5226e0bf38

Check the code in `playground.views.home`.

## Working with Expression Wrappers

> Used for complex expressions.

Check the code in `playground.views.home`.

## Querying Generic Relationships

> In our project, the generic, decoupled model we've is `TaggedItem`.

First we need to get the content type object using following, since `TaggedItem` table is not linked to any model, so it can contain multiple models, I mean tagged item can be a product, and also a collection at the same time.

```py
ContentType.objects.get_for_model(<ModelName>)
```

And then we can query `TaggedItem` for a product.

Check the code in `playground.views.home`.

> Use of `content_object` field in `TaggedItem` model still not clarified.

## Custom Managers

Now, as you might've noticed after looking the code of above section, requiring to do that every single time is very repetitive.

There comes this. Check the code in `tags.models` & `playground.views.home`.

## Understanding QuerySet Cache

> Mosh didn't explain anything.

Just read the concise section: https://docs.djangoproject.com/en/5.2/topics/db/queries/#caching-and-querysets

## Creating Objects

To create an object, instantiate it using keyword arguments to the model class, then call `save()` to save it to the database.  
https://docs.djangoproject.com/en/5.2/topics/db/queries/#creating-objects

`create(**kwargs)`: A convenience method for creating an object and saving it all in one step.  
https://docs.djangoproject.com/en/5.2/ref/models/querysets/#create

Check the code in `playground.views.home`.

## Updating Objects

Saving changes to objects: https://docs.djangoproject.com/en/5.2/topics/db/queries/#saving-changes-to-objects

Updating multiple objects at once: https://docs.djangoproject.com/en/5.2/topics/db/queries/#updating-multiple-objects-at-once

`update()`: https://docs.djangoproject.com/en/5.2/ref/models/querysets/#update

Check the code in `playground.views.home`.

## Deleting Objects

Deleting objects: https://docs.djangoproject.com/en/5.2/topics/db/queries/#deleting-objects

`delete()`: https://docs.djangoproject.com/en/5.2/ref/models/querysets/#delete

Check the code in `playground.views.home`.

## Transactions

> In a transaction, either all the queries should be successful, if even one fail, all the other are rollback-ed as well.

https://docs.djangoproject.com/en/5.2/topics/db/transactions

Check the code in `playground.views.home`.

## Executing Raw SQL Queries

Sometimes using ORM can become complex or slow, at that time, we can just write SQL ourselves.

```py
Model.objects.raw(raw_query)
```

> QuerySet vs. RawQuerySet: https://g.co/gemini/share/2222a9d92831

Also, it's better to use stored procedures instead of writing SQL in the middle of Python code especially for routine query.

```py
django.db.connection.cursor().callproc()
```

```py
django.db.connection.cursor().execute()
```

<br>

Check the code in `playground.views.home`.

Performing raw SQL queries: https://docs.djangoproject.com/en/5.2/topics/db/sql

---

> **CONCLUSION: DJANGO ORM IS A CRAZY PIECE OF TOOL.**
