> **[Important] Revise SQL Joins:**
>
> - [Gemini](https://g.co/gemini/share/af36ff3d1000)
> - [ChatGPT](https://chatgpt.com/share/68ca9b5a-74d8-800a-b42e-5ce8445a01a1)
> - [My Notes - Mosh MySQL Course](https://github.com/samyak1409/sql/blob/main/My%20Scripts/6.%20All%20About%20Joins.sql)

## Django ORM

> Intro to Django ORM: maps objects to relational data, reduces repetitive SQL, speeds development, though complex queries may still need hand-written SQL.

Docs: https://docs.djangoproject.com/en/5.2/topics/db/queries

### What problem does it solve?

We needed to do:

```py
sql = "SELECT * FROM product"
result = execute(sql)
for row in result:
    product = Product()
    product.title = row["title"]
    product.price = row["price"]

# Or at least:
for row in execute("SELECT * FROM product"):
    product = Product(title=row["title"], price=row["price"])
```

[Object-Relational Mapping](https://en.wikipedia.org/wiki/Object–relational_mapping)

Maps the object with the relational records (ORM translates the code to SQL at runtime):

```py
products = Product.objects.all()
```

> **So do we no longer need to know SQL?**  
> No, for complex tasks, we may still need to write queries by ourselves. E.g., ORM could produce inefficient SQL for complex tasks.

<br>

Note that ORMs are a bit slow compared to directly querying the DB due to the obvious reason. But ORMs help ship the app fast. And for most apps, the slow speed is negligible.

> "Premature optimization is the root of all evils."  
> \- Donald Knuth

## Resetting the Database

> Setting up the project: configure DB password, install dependencies, recreate DB, run migrations, seed data, and start server to get synced with course code.

## Managers and QuerySets

> Introduction to Django managers and query sets — managers act as a DB interface, query sets are lazy objects for building complex queries, and they’re only evaluated when iterated, sliced, or converted to a list.

`ModelName.objects` is a `Manager` object, which is basically an interface to the DB.  
It has methods to query the DB like `.all()`, `.get()`, `.filter()`, `.exclude()`. (These are the most used ones.)

https://docs.djangoproject.com/en/5.2/topics/db/queries/#retrieving-objects

- `all`, `filter`, `exclude` return a [QuerySet](https://docs.djangoproject.com/en/5.2/ref/models/querysets/#django.db.models.query.QuerySet) object.
- `get` returns the single object directly.

### [`QuerySet`s are lazy](https://docs.djangoproject.com/en/5.2/topics/db/queries/#querysets-are-lazy)

`QuerySet` is not actually a `set` as the name might indicate. It actually works just like an `Iterator` object.  
Meaning, it evaluates the result (executes DB query) on the go when we actually access the value.

Why?  
Because we frequently chain methods like the following to mimic a complex/nested query:

```py
qs = ModelName.objects.all()
print(qs.filter().order_by().get())
```

If `QuerySet` were not lazy, then the first query would form, result would return (all millions of data) into memory, and then the next query would apply on that.  
That's very inefficient.
So, what actually happens is Django forms the actual SQL query using all the chained methods, and hence directly forms the actual complex/nested query that we wanted.

## Retrieving Objects

> Use `all()` (returns queryset), `get()` (single object, raises exception if not found), or `filter().first()` / `filter().exists()` (safer alternatives to avoid exceptions).

Check the code in `playground.views.test_queries`.

<br>

Fun-fact (researched on my own):  
(Background: As we already know `get` is for a single object only. If the query returns multiple (or zero) objects, then Django raises error.)
But when you do `ModelName.objects.get(column_name=1)`, Django adds a `LIMIT 21` in the SQL query that it executes, which looks weird.

Check the code here: https://github.com/django/django/blame/main/django/db/models/query.py  
Here's the commit in which this was added: https://github.com/django/django/commit/330638b89f14e1fb06e9d313ccc9768ae167c53f

Reason:
`21` is a random/arbitrary number, and it's there as a safeguard if someone mistakenly gets a result that returns millions of records, which can freeze the app.  
Hence, Django only fetches at most 21 records, and then raises `MultipleObjectsReturned` exception. (Meaning Django could've just used `LIMIT 2` to verify, but they probably did it for fun.)

## Filtering Objects

> Use field lookups (`gt`, `gte`, `lt`, `lte`, `range`, `contains`/`icontains`, `startswith`/`endswith`, `year`, `isnull`, etc.) to query numbers, strings, dates, and relationships in Django ORM.

Field lookup types: https://docs.djangoproject.com/en/5.2/ref/models/querysets/#field-lookups

Methods: `filter()`, `exclude()`, `get()`

Syntax:

```py
field_name__lookuptype=value
```

E.g.:

```py
unit_price__gt=20
```

We can also use `__` for nested lookups. E.g., `product` is a foreign key (of any type), and the `Product` table has a field `collection`. We can do: `product__collection`.

Check the code in `playground.views.test_queries`.

<br>

**Note:**

Django Debug Toolbar's `Sel` & `Expl` buttons are not visible for some queries. Why?

> **The code responsible for showing the buttons checks both if the query is a SELECT and if it uses parameters.** If your queries don’t use parameters (values are inlined), the button won’t be shown, even if the query returns results.
>
> E.g.  
> `User.objects.filter(username="alice")`  
> \=  
> `SELECT * FROM user WHERE username = %s`  
> \+  
> `params = ["alice"]`
>
> If you want the "sel" button for those queries, ensure they are parameterized at the SQL level (not just at the Python/Django level). This depends on **how Django ORM translates** your filters to SQL. **Some simple filters may not use parameters.** That's why we don't see the buttons for some queries even when they're similar.
>
> \- [GitHub Copilot Chat 1](https://github.com/copilot/share/4a5a12ba-0000-8447-a911-0e41802a013e), [Chat 2](https://github.com/copilot/share/801a032a-0104-8c61-9800-1e48a46a613d)

Here's the code responsible for this:

- [debug_toolbar/templates/debug_toolbar/panels/sql.html](https://github.com/django-commons/django-debug-toolbar/blob/afd5e7e0be1632abf26fae6d31e3aafec4be788f/debug_toolbar/templates/debug_toolbar/panels/sql.html#L77)
- [debug_toolbar/panels/sql/tracking.py](https://github.com/django-commons/django-debug-toolbar/blob/afd5e7e0be1632abf26fae6d31e3aafec4be788f/debug_toolbar/panels/sql/tracking.py#L149)

(Researched by me.)

## Complex Lookups Using Q Objects

> Complex filtering — combine conditions with multiple filters or `Q` objects for `AND`, `OR`, and `NOT` queries in Django ORM.

> `~` (`NOT`), `|` (`OR`), `&` (`AND`), `^` (`XOR`)

Check the code in `playground.views.test_queries`.

https://docs.djangoproject.com/en/5.2/ref/models/querysets/#q-objects

## Referencing Fields using F Objects

> Use **F objects** to reference model fields (even across related tables) inside queries, enabling field-to-field comparisons.

Check the code in `playground.views.test_queries`.

https://docs.djangoproject.com/en/5.2/ref/models/expressions/#django.db.models.F

## Sorting

> Use **order_by()** (with `-` for descending, multiple fields allowed), **reverse()**, and shortcut methods **earliest() / latest()** for sorting querysets and retrieving objects.

Check the code in `playground.views.test_queries`.

## Limiting Results

> Use **Python slicing on querysets** (`[:5]`, `[5:10]`), which translates to SQL **LIMIT** and **OFFSET** clauses.

Slicing: `QuerySet[OFFSET:OFFSET+LIMIT]`

Check the code in `playground.views.test_queries`.

## Selecting Fields to Query

> Use **`values()` / `values_list()`** to fetch specific fields.

Check the code in `playground.views.test_queries`.

https://docs.djangoproject.com/en/5.2/ref/models/querysets/#values

## Deferring Fields

> Use **`only()`** to load specific fields (returns model instances, risk of N+1 queries if accessing undeclared fields), and **`defer()`** to exclude fields, unlike **`values()`** which returns plain dicts without extra queries.

**Imp:** Pay attention to `<object>.<attr>` (e.g. `Product.description` when only `title` is loaded) usages. Check the code in `playground.views.test_queries`.

- Also, when is it ideal to use `defer`?

  When the particular field would not be accessed at all / accessed very less times (specially when the field is heavy in size).

  Read: [Gemini](https://g.co/gemini/share/59364713ce63)

  So, I think:

  - Not accessed at all - obviously `defer`.
  - Accessed very less times -
    - light weight - don't `defer`, additional DB queries could be more costlier (in terms of time) than loading all the light data in one go.
    - heavy weight - `defer`, additional DB queries could still be less costlier than loading all the heavy data at once.
  - Accessed decent times - don't `defer` else `N+1 query` like problem.

  (Same applies to `only` as well.)

## Selecting Related Objects

> Use **`select_related()`** (for one-to-one/foreign key) and **`prefetch_related()`** (for one-to-many/many-to-many) to preload related objects and avoid N+1 queries.

> `select_related()`: `INNER JOIN` in a single query; used in case of `OneToOneField` & `ForeignKey`
>
> `prefetch_related()`: Separate query + Python join (see the details below); used in case of `ManyToManyField` & reverse `ForeignKey` (i.e., when accessing the `_set` on a model)

Solves classic **N+1 query problem**:

- https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping
- https://planetscale.com/blog/what-is-n-1-query-problem-and-how-to-solve-it

Check the code and **important points** in `playground.views.test_queries`.

### `prefetch_related()` is not straight-forward. Its implementation is smart and optimized.

> [Researched entirely by me.]

```py
Product.objects.prefetch_related("promotions")
```

Should generate the following, right?

```sql
SELECT *
FROM store_product p
INNER JOIN store_product_promotions pp
ON p.id = pp.product_id
```

> See [example](/Notes/Part%201/2.%20Building%20a%20Data%20Model.md#a-concrete-example-students--courses).

But it generates:

```sql
SELECT "store_product"."id",
       "store_product"."title",
       "store_product"."slug",
       "store_product"."description",
       "store_product"."unit_price",
       "store_product"."inventory",
       "store_product"."last_update",
       "store_product"."collection_id"
  FROM "store_product";

SELECT •••
FROM "store_promotion"
INNER JOIN "store_product_promotions"
ON ("store_promotion"."id" = "store_product_promotions"."promotion_id")
WHERE "store_product_promotions"."product_id" IN (<ids from above query>)
```

Doesn't appear to make sense, right? But:

Django's `prefetch_related` uses two queries because it is more efficient than a single `JOIN`. It avoids the primary performance bottleneck: **duplicating the main table's data**.
It achieves this by fetching the main objects first, then fetching all related objects in a second targeted query, and finally stitching the data together in Python. This approach minimizes data transfer and simplifies object creation.

For explanation, read the last responses in the chats:

- [Gemini](https://g.co/gemini/share/b32a073255ed)
- [ChatGPT](https://chatgpt.com/share/687aa433-4588-800a-a83c-58d5ed27e5e8)

## Aggregating Objects

> Use **`aggregate()`** with functions like `Count`, `Min`, `Max`, `Avg`, and `Sum` to compute summary values (returns a dictionary, supports custom keys, and can be combined with filters).

Check the code in `playground.views.test_queries`.

Aggregation functions: https://docs.djangoproject.com/en/5.2/ref/models/querysets/#aggregation-functions

Cheat sheet: https://docs.djangoproject.com/en/5.2/topics/db/aggregation/#cheat-sheet

## Annotating Objects

> **`annotate()`** lets us add extra fields to query results using **expressions** (`Value`, `F`, `Func`, `Aggregate`), e.g., setting constants, referencing fields, or performing computations.

Basically, adding a custom/computed column in SQL while selecting.

Check the code in `playground.views.test_queries`.

https://docs.djangoproject.com/en/5.2/ref/models/querysets/#annotate

## Calling Database Functions

> We can use the generic `Func` class or dedicated helper classes (e.g. `Concat`) for common DB functions like concat.

### When to Use What:

| Use Case                        | Recommended Approach  |
| ------------------------------- | --------------------- |
| Common SQL function             | Use helper class      |
| Custom/unsupported SQL function | Use `Func()` manually |

Check the code in `playground.views.test_queries`.

https://docs.djangoproject.com/en/5.2/ref/models/database-functions

## Grouping Data

**[This topic is important and not very straight-forward, pay extra attention.]**

> Use **`annotate(orders_count=Count("order"))`** to add each customer’s order count (via reverse FK), generating a `LEFT JOIN` + `GROUP BY`.

If we want to see number of orders each customer has placed:

```py
Customer.objects.annotate(Count("order_set"))  # FieldError
Customer.objects.annotate(Count("order"))      # Correct
```

Why?

> (Researched by me.)

- `order_set` is a Python-level manager accessor
- `order` is the database-level relationship name

Read here:

- [Perplexity](https://www.perplexity.ai/search/why-does-instead-of-default-na-cjt6YqS9QcCH.9KyTBLSCg)
- [Gemini](https://g.co/gemini/share/be5226e0bf38)

Check the code **attentively** in `playground.views.test_queries`.

## Working with Expression Wrappers

> Use **`ExpressionWrapper`** with an `output_field` (e.g., `DecimalField`) to safely handle complex expressions with mixed types (like price (decimal) × 0.9 (float)).

Used for complex expressions.

Check the code in `playground.views.test_queries`.

## Querying Generic Relationships

> Use **ContentType + TaggedItem filter (with select_related)** to fetch tags for a product via its `content_type` and `object_id`.

> `TaggedItem` is the generic, decoupled model we've in this project.

First, we need to get the content type object:  
Since `TaggedItem` table is not linked to any model, it can contain multiple models. I mean, tagged item can be a product and also a collection.

```py
ContentType.objects.get_for_model(<ModelName>)
```

Then we can query `TaggedItem` for a product.

Check the code in `playground.views.test_queries`.

## Custom Managers

> Create a **custom manager** with `get_for(object_type, object_id)` to cleanly fetch tags instead of writing raw ContentType filter logic each time.

Now, as you might've noticed after looking at the code of above section, requiring to do that every single time is very repetitive.

There comes overriding managers. Check the code in `tags.models` & `playground.views.test_queries`.

## Understanding QuerySet Cache

> QuerySets use a **cache**: after full evaluation (e.g., `list(qs)`), repeated access reads from memory instead of hitting the DB, but partial evaluation first can cause extra queries.

Mosh didn't explain anything, just read the concise section: [Caching and QuerySets](https://docs.djangoproject.com/en/5.2/topics/db/queries/#caching-and-querysets)

It's very important, must read.

> "Understanding how it works will allow you to write the most efficient code."

## Creating Objects

> Insert records by creating a model instance, setting fields, and calling `.save()`, or use the shorthand `.objects.create(**kwargs)` (though setting fields individually is safer due to IntelliSense and refactor updates).

To create an object, instantiate it using keyword arguments to the model class, then call `save()` to save it to the database.  
https://docs.djangoproject.com/en/5.2/topics/db/queries/#creating-objects

`create(**kwargs)`: A convenience method for creating an object and saving it all in one step.  
https://docs.djangoproject.com/en/5.2/ref/models/querysets/#create

Check the code in `playground.views.test_queries`.

## Updating Objects

> To safely update objects in Django, fetch them from the DB first (avoiding data loss from default field values), or use `QuerySet.update()` for direct updates without loading objects.

Saving changes to objects: https://docs.djangoproject.com/en/5.2/topics/db/queries/#saving-changes-to-objects

Updating multiple objects at once: https://docs.djangoproject.com/en/5.2/topics/db/queries/#updating-multiple-objects-at-once

`update()`: https://docs.djangoproject.com/en/5.2/ref/models/querysets/#update

Check the code in `playground.views.test_queries`.

## Deleting Objects

> Objects can be deleted individually with `obj.delete()` or in bulk using `QuerySet.delete()`.

Deleting objects: https://docs.djangoproject.com/en/5.2/topics/db/queries/#deleting-objects

`delete()`: https://docs.djangoproject.com/en/5.2/ref/models/querysets/#delete

Check the code in `playground.views.test_queries`.

## Transactions

> Use `transaction.atomic` (decorator or context manager) to ensure multiple DB operations execute atomically — committing all or rolling back all on failure.

In a transaction, either all the queries should be successful. If even one fails, all the others are rollback-ed as well.

https://docs.djangoproject.com/en/5.2/topics/db/transactions

Check the code in `playground.views.test_queries`.

## Executing Raw SQL Queries

> Use `Model.objects.raw()` or `connection.cursor()` to execute raw SQL (queries, updates, stored procedures) in Django when ORM queries are too complex or inefficient.

Sometimes using ORM can become complex or slow. At that time, we can just write SQL ourselves.

```py
Model.objects.raw(raw_query)
```

> QuerySet vs. RawQuerySet: [Gemini](https://g.co/gemini/share/2222a9d92831)

Also, it's better to use stored procedures instead of writing SQL in the middle of Python code, especially for routine queries.

```py
django.db.connection.cursor().callproc()
```

```py
django.db.connection.cursor().execute()
```

<br>

Check the code in `playground.views.test_queries`.

Performing raw SQL queries: https://docs.djangoproject.com/en/5.2/topics/db/sql

---

> **CONCLUSION: DJANGO ORM IS A CRAZY PIECE OF ~~SHI~~ TOOL.**
