## Setting Up the Admin Site

> Set up Django admin by creating a superuser, and customizing `admin.site` header/title.

[/admin](http://127.0.0.1:8000/admin)

```sh
python manage.py createsuperuser
```

Changing password:

```sh
python manage.py changepassword <username>
```

<br>

Side-note: We can change the admin headings if we want:  
In the base `urls.py` of our project, just set:

```py
admin.site.site_header = "Storefront Admin"
admin.site.index_title = "Admin"
```

## Registering Models

> Register models in `admin.py`, override `__str__` for readable names, and use `Meta.ordering` to sort objects in the Django admin panel.

Models don't show up on the admin unless we register them.

In a particular app's `admin.py`:

```py
admin.site.register(models.<ModelName>)
```

To see human-readable objects at `127.0.0.1:8000/admin/<app_name>/<modelname>`:  
Define the `__str__` method in the model class.

To set a default ordering of the objects (used in the admin page and while querying, define how objects are returned in a QuerySet by default):

```py
class Meta:
    ordering = ["title", "any_other_field"]
```

## Customizing the List Page

> Customize Django admin list pages using `ModelAdmin` (with `list_display`, `list_editable`, `list_per_page`, `ordering`) to control columns, inline editing, pagination, and sorting.

We can do this by defining a `<Model>Admin` class and setting some attributes.  
Also, if we've added the `<Model>Admin` class, then we should change the `register` to a decorator for better code conciseness & encapsulation:

```py
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ["title", "unit_price"]
    ordering = ["title"]
    list_editable = ["unit_price"]
    list_per_page = 10
```

(`ordering` is redundant here if `ordering` is already set in `class Meta`, unless a different ordering is required in the admin.)

`ModelAdmin` options: https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#modeladmin-options

## Adding Computed Columns

> Add computed columns in Django admin by defining a method in `ModelAdmin`, include it in `list_display`, and use `@admin.display(ordering='field')` to enable sorting.

Suppose we want to display `inventory_status` (Low/OK) instead of `inventory` (or along with it), which is an `int`:

```py
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ["title", "unit_price", "inventory_status", "inventory"]

    @admin.display(ordering="inventory")
    def inventory_status(self, product):
        return "OK" if product.inventory >= 10 else "Low"
```

`@admin.display(ordering='field')`: Enables sorting in the admin list view by this computed column, using the specified model field for ordering (other model fields already support sorting by default).

## Selecting Related Objects

> Loading related objects in Django admin using custom methods + `list_select_related` to prevent N+1 queries (shown with Orderâ†’Customer example).

See: [Django ORM > Selecting Related Objects](/Notes/Part%201/4.%20Django%20ORM.md#selecting-related-objects)

To display a related field's column name in the current table (e.g., we want to display orders with their customer name in the admin order page `/admin/store/order`):

### Sometimes

Only if the field we want to display (in this case, `customer.first_name`) can be used in the `__str__` method of that model class, we can just:

1. Define `__str__` in the `Customer` class with `self.first_name`.
2. Use the following in `admin.py`:

   ```py
   @admin.register(models.Order)
   class OrderAdmin(admin.ModelAdmin):
       list_display = ["id", "customer"]
       ordering = ["id"]
   ```

It's clear why this works.

But what if the field we want to display is not suitable for `__str__`?

### Solution

Just like we did in the ORM section, we can do `customer.first_name`, and just like `select_related()`, we've `list_select_related` attr here to avoid the **N+1 query problem**:

```py
class OrderAdmin(admin.ModelAdmin):
    list_select_related = ["customer"]  # not using this = N+1 query problem

    # Option 1:
    list_display = ["id", "placed_at", "customer__first_name"]

    # Option 2 (use when "customer__first_name" is there multiple times):
    list_display = ["id", "placed_at", "customer_name"]
    def customer_name(self, order):
        return order.customer.first_name
```

> For this particular example, since the `__str__` value is the same as what we want, we don't really need this solution. We can just use: `list_display = ["id", "placed_at", "customer"]`

Check `CustomerAdmin` where it's required to be used.

## Overriding the Base QuerySet

> Django admin: override `get_queryset` to annotate collections with product counts, display via a custom method, and enable sorting using `@admin.display(ordering='product_count')`.

Suppose we want to show the product count on `/admin/store/collection`. We can do:

```py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ["title", "product_count"]

    # @admin.display(ordering="product_count")
    # (FieldError at /admin/store/collection/
    # Cannot resolve keyword 'product_count' into field. Choices are: featured_product, featured_product_id, id, product, title)
    def product_count(self, collection):
        return collection.product_set.count()
```

It works, but sorting can't be enabled for this field.

> "The error occurs because you can't sort by a Python method in the Django admin, as sorting happens at the database level." - [Gemini](https://g.co/gemini/share/ff62df484bbc)

### The Solution: Annotate the QuerySet

Override the `get_queryset` method in `CollectionAdmin` to annotate the queryset with the product count: `.annotate(product_count=Count("product"))`.

```py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ["title", "products"]

    @admin.display(ordering="product_count")
    def products(self, collection):
        return collection.product_count

    def get_queryset(self, request: HttpRequest) -> QuerySet:
        return super().get_queryset(request).annotate(product_count=Count("product"))
```

But, why can't we directly do:

```py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ["title", "product_count"]

    def get_queryset(self, request: HttpRequest) -> QuerySet:
        return super().get_queryset(request).annotate(product_count=Count("product"))
```

[Gemini](https://g.co/gemini/share/18221d247218) says:

> It **doesn't** look at the queryset's annotations because that would be unpredictable. The `ModelAdmin` is designed to be reusable and decoupled. It doesn't assume that every queryset it ever handles will have a specific annotation. By forcing you to define a method (like `products`), you create a stable, explicit "contract." `list_display` knows it can always call `your_admin.products(obj)` and trust it to return a value.

But, doesn't completely makes sense to me. So, I think the reason is: it just doesn't have that "feature".

## Providing Links to Other Pages

> Use `format_html`, `reverse`, and `urlencode` to turn product counts into clickable links that filter the product list by collection.

We can add a link to column values using a computed method:

```py
    def products(self, collection):
        url = (
            reverse("admin:store_product_changelist")
            + "?"
            + urlencode({"collection__id": collection.id})
        )
        return format_html('<a href="{}">{}</a>', url, collection.product_count)
```

- `reverse` - Builds the URL dynamically, independent of any URL pattern changes. Format: `admin:<app_name>_<target_modelname>_<pagetype>`
- `urlencode` - For URL parameters; Passed as key-value pairs in a `dict`
- `format_html` - Securely builds the link while avoiding [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks.

See more examples in `store > admin.py`.

## Adding Search to the List Page

> Enable search with `search_fields`, refine using lookup types (`istartswith`) for case-insensitive, prefix-based search on fields.

Just add to the `<Model>Admin` class:

```py
search_fields = ["first_name", "last_name"]
# We can also add lookup types, e.g., if we want to match from the start + case-insensitive:
search_fields = ["first_name__istartswith", "last_name__istartswith"]
```

This adds a search bar that returns results matched in either of the fields.

## Adding Filtering to the List Page

> Add filtering with `list_filter` for built-in fields and create custom filters by extending `SimpleListFilter` with `lookups` and `queryset` methods (e.g., low inventory filter).

Just add the attr e.g. in `ProductAdmin`:

```py
list_filter = ["collection", "last_update"]
```

And a new side bar will appear with options e.g. to select a collection, and only those products would be shown.  
(This basically uses a `WHERE` clause.)

### Custom Filters

Define an `admin.SimpleListFilter` class:

> Read: [Using a SimpleListFilter](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/filters/#using-a-simplelistfilter)

```py
class InventoryStatusListFilter(admin.SimpleListFilter):
    title = "inventory status"
    parameter_name = "inventory"

    def lookups(self, request: Any, model_admin: Any) -> list[tuple[Any, str]]:
        return [("<10", "Low")]

    def queryset(self, request: Any, queryset: QuerySet[Any]) -> QuerySet[Any] | None:
        if self.value() == "<10":
            return queryset.filter(inventory__lt=10)
```

And then just add the name of the class to the `list_filter` attr.

## Facets

> [Not from the course.] New in Django 5.0. - [Wiki](<https://en.wikipedia.org/wiki/Django_(web_framework)#Version_history>), [Docs](https://docs.djangoproject.com/en/5.2/releases/5.0/#what-s-new-in-django-5-0)

When any filters are there, it shows the count of records corresponding to every filter. Add the following to `<Model>Admin`:

```py
show_facets = admin.ShowFacets.ALWAYS
```

Read: [`ModelAdmin.show_facets`](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.show_facets)

Note: [Performance considerations with facets](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.show_facets:~:text=Performance%20considerations%20with%20facets)

## Creating Custom Actions

> Define custom actions with `@admin.action`, implement logic on selected queryset, and use `message_user` (with `messages` levels) to show feedback (e.g., clear product inventory).

By default, we've the `Delete selected ...` action in the `changelist` pages.

To add a custom action, e.g. setting inventory for selected products to 0, define a function:

```py
@admin.action(description="Clear inventory")
def clear_inventory(self, request, queryset: QuerySet):
    count = queryset.update(inventory=0)
    self.message_user(request, f"Successfully cleared inventory for {count} product(s).")
```

And add:

```py
actions = ["clear_inventory"]
```

Read: [Admin actions](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/actions)

## Customizing Forms

> Use `fields`, `exclude`, `readonly_fields`, `prepopulated_fields`, and `autocomplete_fields` (requires `search_fields` in **related** admin) to control form display and behavior.

`/admin/<app_name>/<modelname>/add`

`<Model>Admin` class attributes:

```py
fields = ["field1", "field2"]  # show these on the `/add` page
# Or
exclude = ["field1", "field2"]  # show all excluding these

readonly_fields = ["field1"]  # show but uneditable

# Now, a cool one:
# As we know we've a `slug` field in `Product`, now, every time we add a new product, we add a title, but this would require us to write a slug ourselves, but it should be auto-generated from the title, so we can do:
prepopulated_fields = {"slug": ["title"]}
# This would auto-generate the `slug` as we write `title` in the form. And is editable.
# Since slug is a `models.SlugField()`, `title` = "Whey Protein" would automatically convert to `slug` = "whey-protein"

# For related (foreign) fields, follow this design solution:
# - If the options are less e.g. `Collection` field in `Product` form, do nothing, django already has the feature where when we type a char, the first matching option would be selected from the dropdown list.
# - If the options are huge e.g. `Customer` field in `Order` form, in the real world, we can have thousands to millions of customers, so it doesn't make sense to show all, here always use following:
# Add to `OrderAdmin`:
autocomplete_fields = ["customer"]
# And to `CustomerAdmin`:
search_fields = ["<field_on_which_we_want_to_search_the_customer>", ...]
# Using this, django doesn't query the DB for all the records, it only queries when we type char, so this not only improves the UX but also the speed since we now have `SELECT + WHERE` instead of just `SELECT`.
```

## Adding Data Validation

> Django model validation: use `null` (DB) vs `blank` (form), add built-in validators (e.g., `MinValueValidator(1)`) for fields like price, and mark optional fields (e.g., `promotions`) with `blank=True`.

In forms, i.e. `/add` pages, basic data validation is already there as per the field types in `models.py`.  
But we can add a lot of custom validations as per our requirement.

### `null`, `blank`

If we want to leave a field empty, we need to have both `null=True, blank=True` in the model field.

e.g.

```py
    description = models.TextField(null=True, blank=True)
```

`null=True` for DB.  
Without this, if `blank=True` is there, then form would get submitted, but then `IntegrityError` would arise since DB rejected the data.

`blank=True` for the field to accept blank value.  
Without this, even if `null=True` is there, form wouldn't submit.

### `validators`

Suppose we've `PositiveIntegerField` which allows 0 by default ("for backward compatibility reasons" - [Docs](https://docs.djangoproject.com/en/5.2/ref/models/fields/#positiveintegerfield)), but we want minimum 1. We can add the following:

```py
inventory = models.PositiveIntegerField(validators=[MinValueValidator(limit_value=1)])
```

This would now not allow 0, and would show a descriptive error message ("Ensure this value is greater than or equal to 1.") by itself.

**All about Validators: https://docs.djangoproject.com/en/5.2/ref/validators**

## Editing Children Using Inlines

> Use `TabularInline` or `StackedInline` to manage related models (e.g., order items) within a parent admin, with options like `autocomplete_fields`, `extra`, `min_num`, and `max_num`.

E.g., we've `Order` & `OrderItem` tables, where `OrderItem` is a child of `Order` (or we can say `Order` is the parent of `OrderItem`) since `OrderItem` has a `ForeignKey` to `Order`.

In cases like these, we can add inline adding/changing (inserting/updating) of children in the parent's `/add` or `/change` page.

Just define a new class:

```py
class OrderItemInline(admin.TabularInline):
    model = models.OrderItem
```

And add the following to `OrderAdmin` class:

```py
    inlines = [OrderItemInline]
```

With this in place, now on `/order/add` & `/order/<pk>/change`, we'd see `OrderItem`'s fields as well.

Also, note that these `Inline` classes support most of the options (attributes) same as `Admin` classes.

**All about Inlines: https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#inlinemodeladmin-objects**

## Using Generic Relations

> Use `GenericTabularInline` with a `TaggedItem` model to manage tags on products.

Suppose we want to inline the `Tag` in `/product` pages. The process is pretty similar with only one difference:

1. Register `models.Tag` in `tags.admin.py`, and add `__str__` in `models.Tag`.

2. Define `TaggedItemInline` class in `store.admin.py`. Only difference is it extends `GenericTabularInline` instead of `TabularInline`. And add to `inlines` in `ProductAdmin`.

That's it.

But, notice we've `model = tags_models.TaggedItem` in `TaggedItemInline`, but still on `/product` page, we're seeing like we did `model = tags_models.Tag`.  
And if we actually change to `model = tags_models.Tag`, we get `SystemCheckError: 'tags.Tag' has no GenericForeignKey'`  
Looks like that's how generic models work.

## Extending Pluggable Apps

> Create a separate `store_custom` app to combine `store` and `tags` features, moving tag-specific admin logic there so `store` stays independent and reusable.

### The Problem

In the above "Using Generic Relations", we had to add `from tags import models as tags_models` so that we can use inside `TaggedItemInline` class.

But this breaks our goal of keeping our apps separate â€” the very reason why we added the generic model in the first place.

### Solution

We need to create a new app. In that app, we would import from both `store` and `tags` apps, and put the implementation of the inline functionality we want, there.

For understanding, watch the video (`Extending Pluggable Apps - 4m 43s`) again.
