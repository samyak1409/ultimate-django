## Setting Up the Admin Site

> [/admin](http://127.0.0.1:8000/admin)

```bash
python manage.py createsuperuser
```

Changing password:

```bash
python manage.py changepassword <username>
```

<br>

Side-note: We can change the admin's headings if required:  
In base `urls.py` of our project, do:

```py
admin.site.site_header = 'Storefront Admin'
admin.site.index_title = 'Admin'
```

## Registering Models

Models don't show up on the admin unless we register them.

In a particular app's `admin.py`:

```py
admin.site.register(models.<ModelName>)
```

To see human-readable objects at `127.0.0.1:8000/admin/<app_name>/<modelname>`:  
Define the `__str__` method in the model class.

To set a default ordering to the objects which would be used in the admin page, and it would also be there while querying defining how the objects are returned in the QuerySet by default:

```py
class Meta:
    ordering = ['title', 'any_other_field']
```

## Customizing the List Page

We can do this by defining a `<Model>Admin` class, and setting some attributes:  
Also, if we've added the `<Model>Admin` class, then we should change the `register` to decorator for code conciseness and encapsulation:

```py
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ["title", "unit_price"]
    ordering = ["title"]
    list_editable = ["unit_price"]
    list_per_page = 10
```

(`ordering` is redundant here if `ordering` is set in `class Meta`, unless different ordering is required in admin.)

`ModelAdmin` options: https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#modeladmin-options

## Adding Computed Columns

Suppose if want to display `inventory_status` (Low/OK) instead of `inventory` (or with `inventory`) which is an `int`:

```py
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ["title", "unit_price", "inventory_status", "inventory"]

    @admin.display(ordering="inventory")
    def inventory_status(self, product):
        return "OK" if product.inventory >= 10 else "Low"
```

## Selecting Related Objects

> See: [Django ORM > Selecting Related Objects](/Notes/Part%201/4.%20Django%20ORM.md#selecting-related-objects)

To display the related field's column name in current table (e.g., we want to display the orders with their customer name in the admin order page `/admin/store/order`):

### Sometimes

Only if the field that we want to display (in current case `customer.first_name`) can be used in `__str__` of that model class, we can just:

1. Define `__str__` in `Customer` class.
2. Have following in `admin.py`:

   ```py
   @admin.register(models.Order)
   class OrderAdmin(admin.ModelAdmin):
       list_display = ["id", "customer"]
       ordering = ["id"]
   ```

Its clear why does this work.

But what if the field we want to display is not suitable for `__str__`?

### Solution

Just like we did in ORM section, we can `customer.first_name`, and just like `select_related()`, we've `list_select_related` attr to not get **N+1 query problem**:

```py
@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ["id", "customer_first_name"]
    ordering = ["id"]
    list_select_related = ["customer"]  # not using this = N+1 query problem

    def customer_first_name(self, order):
        return order.customer.first_name
```

> For this particular example, since `__str__` val is same as what we want, we don't really need this solution.

## Overriding the Base QuerySet

Suppose we want to show the product count on `/admin/store/collection`, we can do:

```py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ["title", "product_count"]

    # @admin.display(ordering="product_count")
    # (FieldError at /admin/store/collection/
    # Cannot resolve keyword 'product_count' into field. Choices are: featured_product, featured_product_id, id, product, title)
    def product_count(self, collection):
        return collection.product_set.count()
```

It works, but sorting can't be enabled for this field.

Read: https://g.co/gemini/share/ff62df484bbc

### The Solution: Annotate the QuerySet

Override the `get_queryset` method in `CollectionAdmin` to annotate the queryset with the product count: `.annotate(products_count=Count('product'))`.

```py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ["title", "product_count"]

    @admin.display(ordering="products_count")
    def product_count(self, collection):
        return collection.products_count

    def get_queryset(self, request: HttpRequest) -> QuerySet:
        return super().get_queryset(request).annotate(products_count=Count("product"))
```

> Notice the difference between `products_count` and `product_count`.

## Providing Links to Other Pages

We can add a link to a column values using computed method:

```py
    def products(self, collection):
        url = (
            reverse("admin:store_product_changelist")
            + "?"
            + urlencode({"collection__id": collection.id})
        )
        return format_html('<a href="{}">{}</a>', url, collection.product_count)
```

- `reverse` - Builds the url dynamically independent on url pattern change. Format: `admin:<app_name>_<target_modelname>_<pagetype>`
- `urlencode` - For url params, passed as key value pairs in `dict`.
- `format_html` - Securely builds the link avoiding [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks.

See more examples in `store > admin.py`.

## Adding Search to the List Page

Just add to the `<Model>Admin` class:

```py
search_fields = ["first_name", "last_name"]
# We can also add lookup types, e.g. if we want to match from starting + case insensitive:
search_fields = ["first_name__istartswith", "last_name__istartswith"]
```

This adds a search bar which would return results matched in either of the fields.

## Adding Filtering to the List Page

Just add the attr e.g. in `ProductAdmin`:

```py
list_filter = ["collection", "last_update"]
```

And a new side bar with appear with options e.g. to select a collection, and only those products would be shown.  
(This basically uses a `WHERE` clause.)

### Custom Filters

Define a `admin.SimpleListFilter` class:

> Read: [Using a SimpleListFilter](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/filters/#using-a-simplelistfilter)

```py
class InventoryStatusListFilter(admin.SimpleListFilter):
    title = "inventory status"
    parameter_name = "inventory"

    def lookups(self, request: Any, model_admin: Any) -> list[tuple[Any, str]]:
        return [("<10", "Low")]

    def queryset(self, request: Any, queryset: QuerySet[Any]) -> QuerySet[Any] | None:
        if self.value() == "<10":
            return queryset.filter(inventory__lt=10)
```

And then just add the name of the class to `list_filter` attr.

## Facets

> New in Django 5.0.

When any filters are there, it shows the count of records corresponding to every filter, add following to `<Model>Admin`:

```py
show_facets = admin.ShowFacets.ALWAYS
```

Read: [`ModelAdmin.show_facets`](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.show_facets)

Note: [Performance considerations with facets](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.show_facets:~:text=Performance%20considerations%20with%20facets)

## Creating Custom Actions

By default, we've `Delete selected ...` action in the `changelist` pages.

To add custom action e.g. setting inventory for selected products to 0, we can define a function:

```py
@admin.action(description="Clear inventory for")
def clear_inventory(self, request, queryset: QuerySet):
    count = queryset.update(inventory=0)
    self.message_user(request, f"Successfully cleared inventory for {count} product(s).")
```

And add following to the `<Model>Admin`:

```py
actions = ["clear_inventory"]
```

Read: [Admin actions](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/actions)

## Customizing Forms

`/admin/<app_name>/<modelname>/add`

`<Model>Admin` class attributes:

```py
fields = ["field1", "field2"]  # show these on the `/add` page
# Or
exclude = ["field1", "field2"]  # show all excluding these

readonly_fields = ["field1"]  # show but uneditable

# Now, a cool one:
# As we know we've a `slug` field in `Product`, now, every time we add a new product, we add a title, but this would require us to write a slug ourselves, but it should be auto-generated from the title, so we can do:
prepopulated_fields = {'slug': ["title"]}
# This would auto-generate the `slug` as we write `title` in the form. And is editable.
# Since slug is a `models.SlugField()`, `title` = "Whey Protein" would automatically convert to `slug` = "whey_protein"

# For related (foreign) fields, follow this design solution:
# - If the options are less e.g. `Collection` field in `Product` form, do nothing, django already has the feature where when we type a char, the first matching option would be selected.
# - If the options are huge e.g. `Customer` field in `Order` form, in the real world, we can have thousands to millions of customers, so it doesn't make sense to show all, here always use following:
# Add to `OrderAdmin`:
autocomplete_fields = ["customer"]
# And to `CustomerAdmin`:
search_fields = ["<field_on_which_we_want_to_search_the_customer>", ...]
# Using this, django doesn't query the DB for all the records, it only queries when we type char, so this not only improves the UX but also the speed since we now have `SELECT + WHERE` instead of just `SELECT`.
```

## Adding Data Validation

In forms, i.e. `/add` pages, basic data validation is already there as per the field types in `models.py`.

But, we can add a lot of custom validations as per our requirement.

### `null`, `blank`

If we want to leave a field empty, we need to have both `null=True, blank=True` in Model field.

e.g.

```py
    description = models.TextField(null=True, blank=True)
```

`null=True` for DB.  
Without this, if `blank=True` is there, then form would get submit, but then `IntegrityError` would arise since DB rejected the data.

`blank=True` for the field to accept blank value.  
Without this, even if `null=True` is there, form wouldn't submit.

### `validators`

Suppose we've a `PositiveIntegerField` which allows 0 by default, but we want minimum 1. We can add following:

```py
inventory = models.PositiveIntegerField(validators=[MinValueValidator(limit_value=1)])
```

This would now don't allow 0, and would show a descriptive error message ("Ensure this value is greater than or equal to 1.") by itself.

**All about Validators: https://docs.djangoproject.com/en/5.2/ref/validators**

## Editing Children Using Inlines

E.g., we've `Order` & `OrderItem` tables, where `OrderItem` is a children of `Order` (or we can say `Order` is the parent of `OrderItem`) since `OrderItem` has a `ForeignKey` to `Order`.

In cases like these, we can add inline adding/changing (inserting/updating) of children in the parent's `/add` or `/change` page.

Just define a new class:

```py
class OrderItemInline(admin.TabularInline):
    model = models.OrderItem
```

And add following to `OrderAdmin` class:

```py
    inlines = [OrderItemInline]
```

With this in place, now on `/order/add` & `/order/<pk>/change`, we'd see `OrderItem`'s fields as well.

Also, note that these `Inline` classes support most of the options (attributes) same as `Admin` classes.

**All about Inlines: https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#inlinemodeladmin-objects**

## Using Generic Relations

Suppose we want to inline the `Tag` in `/product` pages. The process is pretty similar with only one difference:

1. Register `models.Tag` in `tags.admin.py`, and add `__str__` in `models.Tag`.

2. Define `TaggedItemInline` class in `store.admin.py`, only difference is it extends `GenericTabularInline` instead of `TabularInline`. And add to `inlines` in `ProductAdmin`.

That's it. But, notice we've `model = tags_models.TaggedItem` in `TaggedItemInline`, but still on `/product` page, we're seeing like we did `model = tags_models.Tag`.

And, if we actually change to `model = tags_models.Tag`, we get SystemCheckError: `'tags.Tag' has no GenericForeignKey`

Looks like that's how generic models work.

## Extending Pluggable Apps

### The Problem

In above "Using Generic Relations", we had to add `from tags import models as tags_models` so that we can use inside `TaggedItemInline` class.

But, this breaks our goal of keeping our apps separate, the very reason why we added generic model at the first place.

### Solution

We need to create a new app, in that app, we would import from both `store` and `tags` app, and put the implementation of the inline functionality we want, there.

For understanding, watch the video (`Extending Pluggable Apps - 4m 43s`) again.
