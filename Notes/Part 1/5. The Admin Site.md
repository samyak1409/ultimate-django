## Setting Up the Admin Site

> [/admin](http://127.0.0.1:8000/admin)

```bash
python manage.py createsuperuser
```

Changing password:

```bash
python manage.py changepassword <username>
```

<br>

Side-note: We can change the admin headings if required:  
In the base `urls.py` of our project, do:

```py
admin.site.site_header = "Storefront Admin"
admin.site.index_title = "Admin"
```

## Registering Models

Models don't show up on the admin unless we register them.

In a particular app's `admin.py`:

```py
admin.site.register(models.<ModelName>)
```

To see human-readable objects at `127.0.0.1:8000/admin/<app_name>/<modelname>`:  
Define the `__str__` method in the model class.

To set a default ordering of the objects (used in the admin page and when querying, defining how objects are returned in a QuerySet by default):

```py
class Meta:
    ordering = ["title", "any_other_field"]
```

## Customizing the List Page

We can do this by defining a `<Model>Admin` class and setting some attributes.  
Also, if we've added the `<Model>Admin` class, then we should change the `register` to a decorator for better code conciseness and encapsulation:

```py
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ["title", "unit_price"]
    ordering = ["title"]
    list_editable = ["unit_price"]
    list_per_page = 10
```

(`ordering` is redundant here if `ordering` is already set in `class Meta`, unless a different ordering is required in the admin.)

`ModelAdmin` options: https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#modeladmin-options

## Adding Computed Columns

Suppose we want to display `inventory_status` (Low/OK) instead of `inventory` (or along with it), which is an `int`:

```py
@admin.register(models.Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ["title", "unit_price", "inventory_status", "inventory"]

    @admin.display(ordering="inventory")
    def inventory_status(self, product):
        return "OK" if product.inventory >= 10 else "Low"
```

## Selecting Related Objects

> See: [Django ORM > Selecting Related Objects](/Notes/Part%201/4.%20Django%20ORM.md#selecting-related-objects)

To display a related field's column name in the current table (e.g., we want to display orders with their customer name in the admin order page `/admin/store/order`):

### Sometimes

Only if the field we want to display (in this case, `customer.first_name`) can be used in the `__str__` method of that model class, we can just:

1. Define `__str__` in the `Customer` class.
2. Use the following in `admin.py`:

   ```py
   @admin.register(models.Order)
   class OrderAdmin(admin.ModelAdmin):
       list_display = ["id", "customer"]
       ordering = ["id"]
   ```

It's clear why this works.

But what if the field we want to display is not suitable for `__str__`?

### Solution

Just like we did in the ORM section, we can do `customer.first_name`, and just like `select_related()`, we've `list_select_related` attr here to avoid the **N+1 query problem**:

```py
@admin.register(models.Order)
class OrderAdmin(admin.ModelAdmin):
    list_display = ["id", "customer_first_name"]
    ordering = ["id"]
    list_select_related = ["customer"]  # not using this = N+1 query problem

    def customer_first_name(self, order):
        return order.customer.first_name
```

> For this particular example, since the `__str__` value is the same as what we want, we don't really need this solution.

## Overriding the Base QuerySet

Suppose we want to show the product count on `/admin/store/collection`. We can do:

```py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ["title", "product_count"]

    # @admin.display(ordering="product_count")
    # (FieldError at /admin/store/collection/
    # Cannot resolve keyword 'product_count' into field. Choices are: featured_product, featured_product_id, id, product, title)
    def product_count(self, collection):
        return collection.product_set.count()
```

It works, but sorting can't be enabled for this field.

Read: https://g.co/gemini/share/ff62df484bbc

### The Solution: Annotate the QuerySet

Override the `get_queryset` method in `CollectionAdmin` to annotate the queryset with the product count: `.annotate(products_count=Count("product"))`.

```py
@admin.register(models.Collection)
class CollectionAdmin(admin.ModelAdmin):
    list_display = ["title", "product_count"]

    @admin.display(ordering="products_count")
    def product_count(self, collection):
        return collection.products_count

    def get_queryset(self, request: HttpRequest) -> QuerySet:
        return super().get_queryset(request).annotate(products_count=Count("product"))
```

> Notice the difference between `products_count` and `product_count`.

## Providing Links to Other Pages

We can add a link to column values using a computed method:

```py
    def products(self, collection):
        url = (
            reverse("admin:store_product_changelist")
            + "?"
            + urlencode({"collection__id": collection.id})
        )
        return format_html('<a href="{}">{}</a>', url, collection.product_count)
```

- `reverse` - Builds the URL dynamically, independent of any URL pattern changes. Format: `admin:<app_name>_<target_modelname>_<pagetype>`
- `urlencode` - For URL parameters, passed as key-value pairs in a `dict`.
- `format_html` - Securely builds the link while avoiding [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) attacks.

See more examples in `store > admin.py`.

## Adding Search to the List Page

Just add to the `<Model>Admin` class:

```py
search_fields = ["first_name", "last_name"]
# We can also add lookup types, e.g., if we want to match from the start + case-insensitive:
search_fields = ["first_name__istartswith", "last_name__istartswith"]
```

This adds a search bar that returns results matched in either of the fields.

## Adding Filtering to the List Page

Just add the attr e.g. in `ProductAdmin`:

```py
list_filter = ["collection", "last_update"]
```

And a new side bar will appear with options e.g. to select a collection, and only those products would be shown.  
(This basically uses a `WHERE` clause.)

### Custom Filters

Define an `admin.SimpleListFilter` class:

> Read: [Using a SimpleListFilter](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/filters/#using-a-simplelistfilter)

```py
class InventoryStatusListFilter(admin.SimpleListFilter):
    title = "inventory status"
    parameter_name = "inventory"

    def lookups(self, request: Any, model_admin: Any) -> list[tuple[Any, str]]:
        return [("<10", "Low")]

    def queryset(self, request: Any, queryset: QuerySet[Any]) -> QuerySet[Any] | None:
        if self.value() == "<10":
            return queryset.filter(inventory__lt=10)
```

And then just add the name of the class to the `list_filter` attr.

## Facets

> New in Django 5.0.

When any filters are there, it shows the count of records corresponding to every filter. Add the following to `<Model>Admin`:

```py
show_facets = admin.ShowFacets.ALWAYS
```

Read: [`ModelAdmin.show_facets`](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.show_facets)

Note: [Performance considerations with facets](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#django.contrib.admin.ModelAdmin.show_facets:~:text=Performance%20considerations%20with%20facets)

## Creating Custom Actions

By default, we've the `Delete selected ...` action in the `changelist` pages.

To add a custom action, e.g. setting inventory for selected products to 0, we can define a function:

```py
@admin.action(description="Clear inventory for")
def clear_inventory(self, request, queryset: QuerySet):
    count = queryset.update(inventory=0)
    self.message_user(request, f"Successfully cleared inventory for {count} product(s).")
```

And add the following to the `<Model>Admin`:

```py
actions = ["clear_inventory"]
```

Read: [Admin actions](https://docs.djangoproject.com/en/5.2/ref/contrib/admin/actions)

## Customizing Forms

`/admin/<app_name>/<modelname>/add`

`<Model>Admin` class attributes:

```py
fields = ["field1", "field2"]  # show these on the `/add` page
# Or
exclude = ["field1", "field2"]  # show all excluding these

readonly_fields = ["field1"]  # show but uneditable

# Now, a cool one:
# As we know we've a `slug` field in `Product`, now, every time we add a new product, we add a title, but this would require us to write a slug ourselves, but it should be auto-generated from the title, so we can do:
prepopulated_fields = {"slug": ["title"]}
# This would auto-generate the `slug` as we write `title` in the form. And is editable.
# Since slug is a `models.SlugField()`, `title` = "Whey Protein" would automatically convert to `slug` = "whey_protein"

# For related (foreign) fields, follow this design solution:
# - If the options are less e.g. `Collection` field in `Product` form, do nothing, django already has the feature where when we type a char, the first matching option would be selected.
# - If the options are huge e.g. `Customer` field in `Order` form, in the real world, we can have thousands to millions of customers, so it doesn't make sense to show all, here always use following:
# Add to `OrderAdmin`:
autocomplete_fields = ["customer"]
# And to `CustomerAdmin`:
search_fields = ["<field_on_which_we_want_to_search_the_customer>", ...]
# Using this, django doesn't query the DB for all the records, it only queries when we type char, so this not only improves the UX but also the speed since we now have `SELECT + WHERE` instead of just `SELECT`.
```

## Adding Data Validation

In forms, i.e. `/add` pages, basic data validation is already there as per the field types in `models.py`.

But we can add a lot of custom validations as per our requirement.

### `null`, `blank`

If we want to leave a field empty, we need to have both `null=True, blank=True` in the model field.

e.g.

```py
    description = models.TextField(null=True, blank=True)
```

`null=True` for DB.  
Without this, if `blank=True` is there, then form would get submitted, but then `IntegrityError` would arise since DB rejected the data.

`blank=True` for the field to accept blank value.  
Without this, even if `null=True` is there, form wouldn't submit.

### `validators`

Suppose we've a `PositiveIntegerField` which allows 0 by default, but we want minimum 1. We can add the following:

```py
inventory = models.PositiveIntegerField(validators=[MinValueValidator(limit_value=1)])
```

This would now not allow 0, and would show a descriptive error message ("Ensure this value is greater than or equal to 1.") by itself.

**All about Validators: https://docs.djangoproject.com/en/5.2/ref/validators**

## Editing Children Using Inlines

E.g., we've `Order` & `OrderItem` tables, where `OrderItem` is a child of `Order` (or we can say `Order` is the parent of `OrderItem`) since `OrderItem` has a `ForeignKey` to `Order`.

In cases like these, we can add inline adding/changing (inserting/updating) of children in the parent's `/add` or `/change` page.

Just define a new class:

```py
class OrderItemInline(admin.TabularInline):
    model = models.OrderItem
```

And add the following to `OrderAdmin` class:

```py
    inlines = [OrderItemInline]
```

With this in place, now on `/order/add` & `/order/<pk>/change`, we'd see `OrderItem`'s fields as well.

Also, note that these `Inline` classes support most of the options (attributes) same as `Admin` classes.

**All about Inlines: https://docs.djangoproject.com/en/5.2/ref/contrib/admin/#inlinemodeladmin-objects**

## Using Generic Relations

Suppose we want to inline the `Tag` in `/product` pages. The process is pretty similar with only one difference:

1. Register `models.Tag` in `tags.admin.py`, and add `__str__` in `models.Tag`.

2. Define `TaggedItemInline` class in `store.admin.py`. Only difference is it extends `GenericTabularInline` instead of `TabularInline`. And add to `inlines` in `ProductAdmin`.

That's it. But, notice we've `model = tags_models.TaggedItem` in `TaggedItemInline`, but still on `/product` page, we're seeing like we did `model = tags_models.Tag`.

And if we actually change to `model = tags_models.Tag`, we get `SystemCheckError: 'tags.Tag' has no GenericForeignKey'`

Looks like that's how generic models work.

## Extending Pluggable Apps

### The Problem

In the above "Using Generic Relations", we had to add `from tags import models as tags_models` so that we can use inside `TaggedItemInline` class.

But this breaks our goal of keeping our apps separate — the very reason why we added the generic model in the first place.

### Solution

We need to create a new app. In that app, we would import from both `store` and `tags` apps, and put the implementation of the inline functionality we want, there.

For understanding, watch the video (`Extending Pluggable Apps - 4m 43s`) again.
