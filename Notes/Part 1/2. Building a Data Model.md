## Introduction to Data Modeling

> Introduces data modeling in Django by identifying entities (Product, Collection), their attributes, and relationships (one-to-many, optional featured product), as the foundation for an e-commerce project.

Types of relationships:

- One to One (`OneToOneField`)
- One to Many (`ForeignKey`)
- Many to Many (`ManyToManyField`)

## Building an E-commerce Data Model

> Expands the e-commerce data model by adding Cart, CartItem (association class), Customer, Order, OrderItem, and Tag entities, explaining their relationships (one-to-many & many-to-many) and design choices.

<details>
<summary>Association class?</summary>

A special type of class used in UML/data modeling to represent a **relationship that itself has attributes**.

For example:

- `CartItem` is an association class between `Cart` and `Product`.
- A cart can contain many products, and a product can appear in many carts.
- But we also need extra info about this relationship, like **quantity** of the product in the cart.
- Since the relationship has its own data, we don’t just connect Cart ↔ Product directly; instead, we add `CartItem` to store those attributes.

So, in short:
An **association class = relationship + its own attributes.**

</details>

## Organizing Models in Apps

> Covers how to properly break a Django project into apps—avoiding monoliths and over-fragmentation—by grouping related functionality (e.g., store) while keeping optional features (e.g., tags) as separate self-contained apps for high cohesion and low coupling.

- [Monolithic Application](https://en.wikipedia.org/wiki/Monolithic_application): All models live in a single app.  
  **Problem:** Complexity

- [Microservices](https://en.wikipedia.org/wiki/Microservices): Multiple apps, each containing a few models.  
  **Problem:** Interdependence (Coupling)

**Middle ground approach:**

- Apps should be **self-contained** / have **high cohesion**:

  - If we `pip install` an app into another project, it should not require installing other apps just to function correctly.

- Apps should have **zero or minimal coupling**.

## Creating Models

> Shows how to define Django model classes (Product & Customer) with fields, types, options, and primary keys, highlighting best practices like using `DecimalField` for money and Django’s automatic ID field.

API Reference for model fields: https://docs.djangoproject.com/en/5.2/ref/models/fields

<br>

https://docs.djangoproject.com/en/5.2/ref/models/fields/#floatfield:

> `FloatField` vs. `DecimalField`  
> The [`FloatField`](https://docs.djangoproject.com/en/5.2/ref/models/fields/#floatfield) class is sometimes mixed up with the [`DecimalField`](https://docs.djangoproject.com/en/5.2/ref/models/fields/#decimalfield) class. Although they both represent real numbers, they represent those numbers differently. `FloatField` uses Python’s `float` type internally, while `DecimalField` uses Python’s `Decimal` type. For information on the difference between the two, see Python’s documentation for the [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal) module.

https://docs.python.org/3/library/decimal.html#module-decimal:

> The `decimal` module provides support for fast correctly rounded decimal floating-point arithmetic.

**Conclusion:**  
`FloatField` has rounding errors, hence, always use `DecimalField` for sensitive fields like monetary values, which should be completely accurate.

<br>

Why we should just use `CharField.max_length = 255` in most cases instead of more precisely calculated maxes for small fields like `first_name`, `phone`:

- https://chatgpt.com/share/687272f9-c25c-800a-af95-c791f3dbb5be
- https://g.co/gemini/share/152db050dbdf

<br>

**Note:**
Django creates a primary key `id` for every model by default unless a field is explicitly defined with `primary_key=True`.

## Choice Fields

> Explains how to use `choices` in Django model fields with constants for cleaner code, demonstrated through membership levels and an Order model with payment status options.

## Defining One-to-one Relationships

> Demonstrates implementing a one-to-one relationship (Customer–Address) using `OneToOneField` with `on_delete` options, and `primary_key=True` to enforce uniqueness.

`on_delete` options: https://docs.djangoproject.com/en/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete

Some common ones:

- `models.CASCADE`: Deletes the child record when parent is deleted.
- `models.SET_NULL`: Sets foreign key to `NULL`, child record stays.
- `models.SET_DEFAULT`: Sets foreign key to its default value, child record stays.
- `models.PROTECT`: Prevents deletion of parent if children exist (first child record would be needed to be deleted).

Child record is the one which have a foreign key relationship in its definition.  
E.g. Parent: `Customer`, Child: `Address`  
In `Address` model:  
`customer = models.OneToOneField()`

### Auto Reverse Relationships

In Django, when we define a relationship from one model to another, a **reverse relationship** is automatically created on the related (parent) model.

> Important to note that field/column is not added in the DB, by above I mean that we can use the reverse relation with Django ORM code. (It queries the DB to get the result from the parent model table.) Got it?

- For example, Django adds a reverse relation on `Customer` named `address` by default.
- The reverse relation name is:

  - **`<modelname>`** — if it's a **OneToOneField**
  - **`<modelname>_set`** — if it's a **ForeignKey** (One-to-Many) or **ManyToManyField**

This allows you to access related objects from the parent model using the reverse name.

> Doubt: We can already get address from customer and vice versa, then why exactly do we need this?
>
> See the requirement in `playground.views.test_queries` > "Selecting Related Objects" section > Exercise (in the end).

## Defining a One-to-Many Relationship

> Explains implementing one-to-many relationships using `ForeignKey`, with examples like Collection–Products, Customer–Orders, Order–OrderItems, and Cart–CartItems, along with appropriate `on_delete` behaviors.

Note:  
If we want to define a foreign relationship, the other class needs to be defined above in order to reference it.  
If that's not possible (in case of circular relationship), pass the name of the class **as a string**.  
But, only do this in case of circular relationship, not when you can just move the class above, since if we ever wanted to rename the class, we might forget to rename in the string.

## Defining Many-to-Many Relationships

> Covers defining many-to-many relationships using `ManyToManyField` with an example of Products–Promotions, and Django’s automatic reverse relation (`promotion.product_set`).

### Important: How exactly many to many fields are stored in the DB?

A many-to-many relationship isn't stored in a single database column. It's managed using a third, intermediate junction table (automatically created, named "app_name_modelname_field_name") that contains foreign keys to the two tables being linked. The "field" in your application code is an abstraction that runs `JOIN` queries on this junction table to get the related data.

Read here: [Gemini](https://g.co/gemini/share/db60c19a2a87)

#### A Concrete Example: Students & Courses

Let's model a classic M2M relationship: Students can enroll in many Courses, and a Course can have many Students.

**Table: `Students`**
| `id` (PK) | `name` |
| :-------- | :----- |
| 1         | Alice  |
| 2         | Bob    |

**Table: `Courses`**
| `id` (PK) | `title`            |
| :-------- | :----------------- |
| 101       | Intro to SQL       |
| 102       | Python Programming |

Here is the crucial **junction table**, which we'll call `Enrollment`.

**Table: `Enrollment`**
(Primary Key is a composite of `student_id` and `course_id`)
| `student_id` (FK) | `course_id` (FK) |
| :---------------- | :--------------- |
| 1                 | 101              |
| 1                 | 102              |
| 2                 | 102              |

This structure tells us:

- Alice (student `1`) is enrolled in SQL (course `101`) and Python (course `102`).
- Bob (student `2`) is enrolled in Python (course `102`).

To get all courses for Alice, the database would run a query similar to this:

```sql
SELECT C.id, C.title
FROM Courses AS C
INNER JOIN Enrollment AS E
ON C.id = E.course_id
WHERE E.student_id = 1;
```

> Remove `WHERE` clause to get all courses for all students.

## Resolving Circular Relationships

> Explains handling circular dependencies in Django models (e.g., Collection–Product) using string references in `ForeignKey`, and resolving reverse relation conflicts with `related_name`.

See `store.models.Collection` class.

To avoid name clash in case of circular dependency:

- **No reverse relation needed?**
  Use:

  ```py
  related_name="+"
  ```

- **Need a custom reverse relation name?**
  Use:

  ```py
  related_name="custom_name"
  ```

https://docs.djangoproject.com/en/5.2/ref/models/fields/#django.db.models.ForeignKey.related_name

## Generic Relationships

> Explains implementing generic relationships using `ContentType`, `object_id`, and `GenericForeignKey`, demonstrated through reusable tagging and likes apps.

As discussed in the `Organizing Models in Apps`, we have a separate app `tags`.  
Now, to define the model, we should use a generic `ContentType` model instead of our actual model(s). So that the app is not actually related, and can be used in any other project as is.

> `ContentType` model is specifically made for allowing generic relationships. It's part of the built-in Django app `contenttypes`.

To define a generic relationship, we need to define three fields in total:

```py
content_type = models.ForeignKey(to=ContentType, on_delete=...)
object_id = models.PositiveIntegerField()
content_object = GenericForeignKey()
```

Read how it works: [Gemini](https://g.co/gemini/share/d7fc1a0b3bb1)
