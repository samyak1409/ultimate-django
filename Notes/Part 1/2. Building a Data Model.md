## Introduction to Data Modeling

Types of relationships:

- One to One (`OneToOneField`)
- One to Many (`ForeignKey`)
- Many to Many (`ManyToManyField`)

## Building an E-commerce Data Model

## Organizing Models in Apps

- [Monolithic Application](https://en.wikipedia.org/wiki/Monolithic_application): All models live in a single app.  
  **Problem:** Complexity

- [Microservices](https://en.wikipedia.org/wiki/Microservices): Multiple apps, each containing a few models.  
  **Problem:** Interdependence (Coupling)

**Middle ground approach:**

- Apps should be **self-contained** / have **high cohesion**:

  - If we `pip install` an app into another project, it should not require installing other apps just to function correctly.

- Apps should have **zero or minimal coupling**.

## Creating Models

API Reference for model fields: https://docs.djangoproject.com/en/stable/ref/models/fields

<br>

https://docs.djangoproject.com/en/5.2/ref/models/fields/#floatfield:

> `FloatField` vs. `DecimalField`  
> The [`FloatField`](https://docs.djangoproject.com/en/5.2/ref/models/fields/#floatfield) class is sometimes mixed up with the [`DecimalField`](https://docs.djangoproject.com/en/5.2/ref/models/fields/#decimalfield) class. Although they both represent real numbers, they represent those numbers differently. `FloatField` uses Python’s `float` type internally, while `DecimalField` uses Python’s `Decimal` type. For information on the difference between the two, see Python’s documentation for the [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal) module.

https://docs.python.org/3/library/decimal.html#module-decimal:

> The `decimal` module provides support for fast correctly rounded decimal floating-point arithmetic.

**Conclusion:**  
`FloatField` has rounding errors, hence, always use `DecimalField` for sensitive fields like monetary values, which should be completely accurate.

<br>

Why we should just use `CharField.max_length = 255` in most cases instead of more precisely calculated maxes for small fields like `first_name`, `phone`:

- [https://chatgpt.com/share/687272f9-c25c-800a-af95-c791f3dbb5be](https://chatgpt.com/share/687272f9-c25c-800a-af95-c791f3dbb5be)
- [https://g.co/gemini/share/152db050dbdf](https://g.co/gemini/share/152db050dbdf)

<br>

**Note:**
Django creates a primary key `id` for every model by default unless a field is explicitly defined with `primary_key=True`.

## Choice Fields

## Defining One-to-one Relationships

`models.OneToOneField`

<br>

`on_delete` options: https://docs.djangoproject.com/en/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete

Some common ones:

- `models.CASCADE`: Deletes the child record when parent is deleted.
- `models.SET_NULL`: Sets foreign key to `NULL`, child record stays.
- `models.SET_DEFAULT`: Sets foreign key to its default value, child record stays.
- `models.PROTECT`: Prevents deletion of parent if children exist (first child record would be needed to be deleted).

Child record is the one which have a foreign key relationship in its definition.  
E.g. Parent: `Customer`, Child: `Address`  
In `Address` model:  
`customer = models.OneToOneField()`

<br>

### Auto Reverse Relationships

In Django, when we define a relationship from one model to another, a **reverse relationship** is automatically created on the related (parent) model.

- For example, Django adds a reverse relation on `Customer` named `address` by default.
- The reverse relation name is:

  - **`<modelname>`** — if it's a **OneToOneField**
  - **`<modelname>_set`** — if it's a **ForeignKey** (One-to-Many) or **ManyToManyField**

This allows you to access related objects from the parent model using the reverse name.

> Doubt: We can already get address from customer and vice versa, then why exactly do we need this?
> 
> See the requirement in `playground.views.home` > "Selecting Related Objects" section > Exercise (in the end).

## Defining a One-to-Many Relationship

`models.ForeignKey`

Note:  
If we want to define a foreign relationship, the other class needs to be defined above in order to reference it.  
If that's not possible (in case of circular relationship), pass the name of the class **as a string**.  
But, only do this in case of circular relationship, not when you can just move the class above, since if we ever wanted to rename the class, we might forget to rename in the string.

## Defining Many-to-Many Relationships

`models.ManyToManyField`

### Important: How exactly many to many fields are stored in the DB?

A many-to-many relationship isn't stored in a single database column. It's managed using a third, intermediate junction table (automatically created, named "app_name_modelname_field_name") that contains foreign keys to the two tables being linked. The "field" in your application code is an abstraction that runs `JOIN` queries on this junction table to get the related data.

Read here: https://g.co/gemini/share/db60c19a2a87

#### A Concrete Example: Students & Courses

Let's model a classic M2M relationship: Students can enroll in many Courses, and a Course can have many Students.

**Table: `Students`**
| `id` (PK) | `name` |
| :-------- | :----- |
| 1         | Alice  |
| 2         | Bob    |

**Table: `Courses`**
| `id` (PK) | `title`            |
| :-------- | :----------------- |
| 101       | Intro to SQL       |
| 102       | Python Programming |

Here is the crucial **junction table**, which we'll call `Enrollment`.

**Table: `Enrollment`**
(Primary Key is a composite of `student_id` and `course_id`)
| `student_id` (FK) | `course_id` (FK) |
| :---------------- | :--------------- |
| 1                 | 101              |
| 1                 | 102              |
| 2                 | 102              |

This structure tells us:

- Alice (student `1`) is enrolled in SQL (course `101`) and Python (course `102`).
- Bob (student `2`) is enrolled in Python (course `102`).

To get all courses for Alice, the database would run a query similar to this:

```sql
SELECT C.id, C.title
FROM Courses AS C
INNER JOIN Enrollment AS E
ON C.id = E.course_id
WHERE E.student_id = 1;
```

> Remove `WHERE` clause to get all courses for all students.

## Resolving Circular Relationships

See `store.models.Collection` class.

To avoid name clash in case of circular dependency:

- **No reverse relation needed?**
  Use:

  ```py
  related_name="+"
  ```

- **Need a custom reverse relation name?**
  Use:

  ```py
  related_name="custom_name"
  ```

https://docs.djangoproject.com/en/5.2/ref/models/fields/#django.db.models.ForeignKey.related_name

## Generic Relationships

As discussed in the `Organizing Models in Apps`, we have a separate app `tags`.  
Now, to define the model, we should use a generic `ContentType` model instead of our actual model(s). So that the app is not actually related, and can be used in any other project as is.

> `ContentType` model is specifically made for allowing generic relationships. It's part of the built-in Django app `contenttypes`.

To define a generic relationship, we need to define three fields in total:

```py
content_type = models.ForeignKey(to=ContentType, on_delete=...)
object_id = models.PositiveIntegerField()
content_object = GenericForeignKey()
```
