## Introduction to Data Modeling

> Introduces data modeling in Django by identifying entities (Product, Collection), their attributes, and relationships (one-to-many, optional featured product), as the foundation for an e-commerce project.

Types of relationships:

- One to One (`OneToOneField`)
- One to Many (`ForeignKey`)
- Many to Many (`ManyToManyField`)

## Building an E-commerce Data Model

> Expands the e-commerce data model by adding Cart, CartItem (association class), Customer, Order, OrderItem, and Tag entities, explaining their relationships (one-to-many & many-to-many) and design choices.

<details>
<summary>Association class?</summary>

A special type of class used in UML (Unified Modeling Language) / data modeling to represent a **relationship that itself has attributes**.

For example:

- `CartItem` is an association class between `Cart` and `Product`.
- A cart can contain many products, and a product can appear in many carts.
- But we also need extra info about this relationship, like **quantity** of the product in the cart.
- Since the relationship has its own data, we don’t just connect Cart ↔ Product directly; instead, we add `CartItem` to store those attributes.

So, in short:
An **association class = relationship + its own attributes.**

</details>

## Organizing Models in Apps

> Covers how to properly break a Django project into apps—avoiding monoliths and over-fragmentation—by grouping related functionality (e.g., product, cart, order) while keeping optional features (e.g., tags) as separate self-contained apps for high cohesion and low coupling.

> Cohesion vs Coupling:  
> **Cohesion** measures how well the elements within a single module work together, while **coupling** measures the degree of interdependence between different modules. The goal of good software design is to have **high cohesion** (elements in a module are strongly related) and **low coupling** (modules are independent of each other). This makes the software more modular, maintainable, and easier to understand.
> Alright, Samyak, here’s a clean, crisp, **concise set of notes** from that whole explanation — but still clear enough so you remember the logic without rewatching anything.

- A Django **project** contains multiple **apps**.
  Each app should represent **one focused piece of functionality**.

- **Bad Approach 1: One Giant “store” App**

  - All models/features dumped into a single app.
  - Becomes a **monolith** → bloated, hard to maintain, hard to understand, hard to reuse.

- **Bad Approach 2: Too Many Fine-Grained Apps**
  Example: products, customers, cart, orders.
  Problems:

  - Apps become **dependent** on each other (cart → products; orders → cart).
  - Hard to reuse in future projects because you must install multiple interdependent apps.
  - Updating one app may break others → tightly coupled.
  - Some features make no sense alone (e.g., cart without products).

- **Correct Approach: Balanced App Boundaries**

  - Avoid both extremes (huge monolith, tiny tightly-coupled components).
  - Use **high cohesion** (each app focuses on one purpose).
  - Use **low coupling** (apps shouldn’t rely on each other unnecessarily).

- **Example: Tagging System**

  - Tag functionality is **generic**, not exclusive to e-commerce.
  - Should be placed in a separate `tags` app with:

    - `Tag`
    - `TagItem` (generic link: product, article, video, etc.)

  - Completely reusable in any type of project.

- **Resulting Good Design**

  - `store` app → product catalog + cart + orders (all highly related, so grouped).
  - `tags` app → independent, reusable elsewhere.
  - Apps can be updated or reused **independently** with minimal risk.

---

Note that above was not **Monolith vs Microservices**, but **Monolith vs <u>Modular Monolith</u>**.

<details>
<summary>Gemini</summary>

### How to Answer in an Interview

If an interviewer asks: _"What is the difference between Monolith and Microservices?"_

**Don't say:** "Monolith is one app, Microservices is multiple Django apps." (This is wrong).

**Say this instead:**

> "A **Monolithic** architecture is where all functional components (Auth, Products, Orders) sit in a **single codebase** and are deployed together as a distinct unit. They share the same memory and database. Even if we organize a Django project into multiple 'apps' (like `users` and `products`), it's still a **Modular Monolith** because they communicate via direct Python imports.

>

> **Microservices**, on the other hand, are when we split those components into **physically separate applications**, often in different repositories. They run on different servers/ports, have their own distinct databases, and communicate over a network using **HTTP APIs** or message queues."

### TL;DR

- **You were right.** Codebase sharing = Monolith.

- **Mosh's approach:** Modular Monolith (Good for 99% of startups).

- **True Microservices:** Separate Repos, Separate DBs, API communication (Needed for Google/Netflix scale).

</details>

<details>
<summary>ChatGPT</summary>

### Interview-ready

- “Django apps are _code modules_. Monolith vs microservice is about _deployability & runtime independence_. Multiple apps in one Django project → monolith unless you extract them into separate services with independent runtimes and data.”
- “Microservices = independent deployable units + own data ownership + network communication. Apps in the same Django process are not microservices.”

### TLDR

- Django apps ≠ microservices.
- Microservices require independent deploy/run/data boundaries and API-driven communication.
- Start modular monolith, extract services when you need independent scale, teams, or release cycles.

</details>

## Creating Models

> Shows how to define Django model classes (Product & Customer) with fields, types, options, and primary keys, highlighting best practices like using `DecimalField` for money and Django’s automatic ID field.

API Reference for model fields: https://docs.djangoproject.com/en/5.2/ref/models/fields

<br>

https://docs.djangoproject.com/en/5.2/ref/models/fields/#floatfield:

> `FloatField` vs. `DecimalField`  
> The [`FloatField`](https://docs.djangoproject.com/en/5.2/ref/models/fields/#floatfield) class is sometimes mixed up with the [`DecimalField`](https://docs.djangoproject.com/en/5.2/ref/models/fields/#decimalfield) class. Although they both represent real numbers, they represent those numbers differently. `FloatField` uses Python’s `float` type internally, while `DecimalField` uses Python’s `Decimal` type. For information on the difference between the two, see Python’s documentation for the [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal) module.

https://docs.python.org/3/library/decimal.html#module-decimal:

> The `decimal` module provides support for fast correctly rounded decimal floating-point arithmetic.

**Conclusion:**  
`FloatField` has rounding errors, hence, always use `DecimalField` for sensitive fields like monetary values, which should be completely accurate.

<br>

Why we should just use `CharField.max_length = 255` in most cases instead of more precisely calculated maxes for small fields like `first_name`, `phone`:

- https://chatgpt.com/share/687272f9-c25c-800a-af95-c791f3dbb5be
- https://g.co/gemini/share/152db050dbdf

<br>

**Note:**
Django creates a primary key `id` for every model by default unless a field is explicitly defined with `primary_key=True`.

## Choice Fields

> Explains how to use `choices` in Django model fields with constants for cleaner code, demonstrated through membership levels and an Order model with payment status options.

## Defining One-to-one Relationships

> Demonstrates implementing a one-to-one relationship (Customer–Address) using `OneToOneField` with `on_delete` options, and `primary_key=True` to enforce uniqueness.

`on_delete` options: https://docs.djangoproject.com/en/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete

Some common ones:

- `models.CASCADE`: Deletes the child record when parent is deleted.
- `models.SET_NULL`: Sets foreign key to `NULL`, child record stays.
- `models.SET_DEFAULT`: Sets foreign key to its default value, child record stays.
- `models.PROTECT`: Prevents deletion of parent if children exist (first child record would be needed to be deleted).

Child record is the one which have a foreign key relationship in its definition.  
E.g. Parent: `Customer`, Child: `Address`  
In `Address` model:  
`customer = models.OneToOneField()`

### Auto Reverse Relationships

In Django, when we define a relationship from one model to another, a **reverse relationship** is automatically created on the related (parent) model.

> Important to note that field/column is not added in the DB, by above I mean that we can use the reverse relation with Django ORM code. (It queries the DB to get the result from the parent model table.) Got it?

- For example, Django adds a reverse relation on `Customer` named `address` by default.
- The reverse relation name is:

  - **`<modelname>`** — if it's a **OneToOneField**
  - **`<modelname>_set`** — if it's a **ForeignKey** (One-to-Many) or **ManyToManyField**

This allows you to access related objects from the parent model using the reverse name.

> Doubt: We can already get address from customer and vice versa, then why exactly do we need this?
>
> See the requirement in `playground.views.test_queries` > "Selecting Related Objects" section > Exercise (in the end).

## Defining a One-to-Many Relationship

> Explains implementing one-to-many relationships using `ForeignKey`, with examples like Collection–Products, Customer–Orders, Order–OrderItems, and Cart–CartItems, along with appropriate `on_delete` behaviors.

Note:  
If we want to define a foreign relationship, the other class needs to be defined above in order to reference it.  
If that's not possible (in case of circular relationship), pass the name of the class **as a string**.  
But, only do this in case of circular relationship, not when you can just move the class above, since if we ever wanted to rename the class, we might forget to rename in the string.

## Defining Many-to-Many Relationships

> Covers defining many-to-many relationships using `ManyToManyField` with an example of Products–Promotions, and Django’s automatic reverse relation (`promotion.product_set`).

### Important: How exactly many to many fields are stored in the DB?

A many-to-many relationship isn't stored in a single database column. It's managed using a third, intermediate junction table (automatically created, named "app_name_modelname_field_name") that contains foreign keys to the two tables being linked. The "field" in your application code is an abstraction that runs `JOIN` queries on this junction table to get the related data.

Read here: [Gemini](https://g.co/gemini/share/db60c19a2a87)

#### A Concrete Example: Students & Courses

Let's model a classic M2M relationship: Students can enroll in many Courses, and a Course can have many Students.

**Table: `Students`**
| `id` (PK) | `name` |
| :-------- | :----- |
| 1         | Alice  |
| 2         | Bob    |

**Table: `Courses`**
| `id` (PK) | `title`            |
| :-------- | :----------------- |
| 101       | Intro to SQL       |
| 102       | Python Programming |

Here is the crucial **junction table**, which we'll call `Enrollment`.

**Table: `Enrollment`**
(Primary Key is a composite of `student_id` and `course_id`)
| `student_id` (FK) | `course_id` (FK) |
| :---------------- | :--------------- |
| 1                 | 101              |
| 1                 | 102              |
| 2                 | 102              |

This structure tells us:

- Alice (student `1`) is enrolled in SQL (course `101`) and Python (course `102`).
- Bob (student `2`) is enrolled in Python (course `102`).

To get all courses for Alice, the database would run a query similar to this:

```sql
SELECT C.id, C.title
FROM Courses AS C
INNER JOIN Enrollment AS E
ON C.id = E.course_id
WHERE E.student_id = 1;
```

> Remove `WHERE` clause to get all courses for **all** students.

## Resolving Circular Relationships

> Explains handling circular dependencies in Django models (e.g., Collection–Product) using string references in `ForeignKey`, and resolving reverse relation conflicts with `related_name`.

See `store.models.Collection` class.

Resolve reverse relation conflicts:

- Tell Django to skip creating reverse relation:

  ```py
  related_name="+"
  ```

- Or give a custom name:

  ```py
  related_name="custom_name"
  ```

https://docs.djangoproject.com/en/5.2/ref/models/fields/#django.db.models.ForeignKey.related_name

## Generic Relationships

> Explains implementing generic relationships using `ContentType`, `object_id`, and `GenericForeignKey`, demonstrated through reusable tagging and likes apps.

As discussed in the `Organizing Models in Apps`, we have a separate app `tags`.  
Now, for defining the relationship, we should use a generic `ContentType` model instead of our actual model(s). So that the app is not actually related, and can be used in any other project as is.

> `ContentType` model is specifically made for allowing generic relationships. It's part of the built-in Django app `contenttypes`.

To define a generic relationship, we need to define three fields in total:

```py
content_type = models.ForeignKey(to=ContentType, on_delete=...)
object_id = models.PositiveIntegerField()
content_object = GenericForeignKey()
```

---

### What exactly is `content_object` and its use in a generic model in Django?

In a generic model in Django, **`content_object` is a special attribute that gives you the actual Python object that a generic relationship is pointing to.**

It's not a real field in your database. Instead, it's a convenience property created by a `GenericForeignKey` that uses two other database fields—`content_type` and `object_id`—to find and return the related model instance.

Think of it this way:

- `content_type`: Tells you _which model_ (which database table) to look at.
- `object_id`: Tells you _which specific row_ (which object) in that table to get.
- `content_object`: Combines the two to give you the actual object itself.

So:

- **`content_object`** is a virtual attribute provided by Django's `GenericForeignKey`.
- It allows one model (e.g., `Comment`, `Tag`) to have a relationship with **any other model** in your project.
- It works by using two database columns: `content_type` (the model's type) and `object_id` (the model instance's primary key).
- You use it to **get** the related object (e.g., `my_tag.content_object`) or to **set** the relationship when creating a new object (e.g., `TaggedItem.objects.create(content_object=my_article)`).
- It's the key to building flexible, reusable apps like tagging or notification systems.

\- [Gemini](https://g.co/gemini/share/d7fc1a0b3bb1)
