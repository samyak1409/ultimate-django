## Introduction to Data Modeling

Types of relationships:

- One to One
- One to Many
- Many to Many

## Organizing Models in Apps

- [Monolithic Application](https://en.wikipedia.org/wiki/Monolithic_application): All models live in a single app.  
  **Problem:** Complexity

- [Microservices](https://en.wikipedia.org/wiki/Microservices): Multiple apps, each containing a few models.  
  **Problem:** Interdependence (Coupling)

**Middle ground approach:**

- Apps should be **self-contained** / have **high cohesion**:

  - If we `pip install` an app into another project, it should not require installing other apps just to function correctly.

- Apps should have **zero or minimal coupling**.

## Creating Models

API Reference for model fields: https://docs.djangoproject.com/en/stable/ref/models/fields

<br>

https://docs.djangoproject.com/en/5.2/ref/models/fields/#floatfield:

> `FloatField` vs. `DecimalField`  
> The [`FloatField`](https://docs.djangoproject.com/en/5.2/ref/models/fields/#floatfield) class is sometimes mixed up with the [`DecimalField`](https://docs.djangoproject.com/en/5.2/ref/models/fields/#decimalfield) class. Although they both represent real numbers, they represent those numbers differently. `FloatField` uses Python’s `float` type internally, while `DecimalField` uses Python’s `Decimal` type. For information on the difference between the two, see Python’s documentation for the [`decimal`](https://docs.python.org/3/library/decimal.html#module-decimal) module.

https://docs.python.org/3/library/decimal.html#module-decimal:

> The `decimal` module provides support for fast correctly rounded decimal floating-point arithmetic.

**Conclusion:**  
`FloatField` has rounding errors, hence, always use `DecimalField` for sensitive fields like monetory values, which should be completely accurate.

<br>

Why we should just use `CharField.max_length = 255` in most cases instead of more precisely calculated maxes for small fields like `first_name`, `phone`:

- [https://chatgpt.com/share/687272f9-c25c-800a-af95-c791f3dbb5be](https://chatgpt.com/share/687272f9-c25c-800a-af95-c791f3dbb5be)
- [https://g.co/gemini/share/152db050dbdf](https://g.co/gemini/share/152db050dbdf)

<br>

**Note:**
Django creates a primary key `id` for every model by default unless a field is explicitly defined with `primary_key=True`.

## Defining One-to-one Relationships

`models.OneToOneField`

<br>

`on_delete` options: https://docs.djangoproject.com/en/5.2/ref/models/fields/#django.db.models.ForeignKey.on_delete

Some common ones:

- `models.CASCADE`: Deletes the child record when parent is deleted.
- `models.SET_NULL`: Sets foreign key to `NULL`, child record stays.
- `models.SET_DEFAULT`: Sets foreign key to its default value, child record stays.
- `models.PROTECT`: Prevents deletion of parent if children exist (first child record would be needed to be deleted).

Child record is the one which have a foreign key relationship in its definition.  
E.g. Parent: `Customer`, Child: `Address`  
In `Address` model:  
`customer = models.OneToOneField()`

<br>

Django automatically creates a reverse relationship named `address` in the parent class `Customer`.  
But why? We can already get address from customer and vice versa, then why do we need this?

## Defining a One-to-Many Relationship

`models.ForeignKey`

Note:  
If we want to define a foreign relationship, the other class needs to be defined above in order to reference it.  
If that's not possible (in case of circular relationship), pass the name of the class **as a string**.  
But, only do this in case of circular relationship, not when you can just move the class above, since if we ever wanted to rename the class, we might forget to rename in the string.

## Defining Many-to-Many Relationships

`models.ManyToManyField`

## Resolving Circular Relationships

See `store.models.Collection` class.

To avoid name clash in case of circular dependency:

- **No reverse relation needed?**
  Use:

  ```py
  related_name='+'
  ```

- **Need a custom reverse relation name?**
  Use:

  ```py
  related_name='custom_name'
  ```

https://docs.djangoproject.com/en/5.2/ref/models/fields/#django.db.models.ForeignKey.related_name

## Generic Relationships

As discussed in the `Organizing Models in Apps`, we have a separate app `tags`.  
Now, to define the model, we should use a generic `ContentType` model instead of our actual model(s). So that the app is not actually related, and can be used in any other project as is.

> `ContentType` model is specifically made for allowing generic relationships. It's part of the built-in Django app `contenttypes`.

To define a generic relationship, we need to define three fields in total:

```py
content_type = models.ForeignKey(to=ContentType, on_delete=...)
object_id = models.PositiveIntegerField()
content_object = GenericForeignKey()
```

> Not completely understood...
