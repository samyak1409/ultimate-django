## Supported Database Engines

https://docs.djangoproject.com/en/5.2/ref/databases

Default: SQLite - should only be used for development / personal projects with no traffic.

> SQLite is a serverless db.

For production, most popular: PostgreSQL, MySQL

> Mosh is using MySQL, but I'd use **Postgres** since it's **more popular** in Django.

## Creating Migrations

`makemigrations` - creates app-wise migration files using the current state of models in a app

Files are made with name `XXXX_description.py` where XXXX is a the id starting with `0001`.  
First file is made with name `0001_initial.py`.  
We can change this name though by simply renaming the file, but we need to also rename all the references of it from the other migration files.  
Sometimes when the changes are not straight-forward, django can't form a description string, so it creates the file with a vague string, in this case, do rename the file for better tracking.

Whenever `makemigrations` is done again, if there are any changes, new migration file is created.  
(Each migration file is like a commit in git.)

<br>

When a field (i.e. column) is added later in the model, there should be a value to populate all the previous records.
- Option 1: make the field null-able with `null=True`
- Option 2: add a default `default='something'`
- Option 3: supply a default val in the terminal, this would not be saved in the models, but only for all the previous records. (This would be saved in the current migration file.)

Choice depends on our requirements.

# Running Migrations

`migrate` - converts the migration files into actual SQL code according to the current DB, and run them to actually make all the changes in the DB

> VS Code extension [`sqlite`](https://marketplace.visualstudio.com/items?itemName=alexcvzz.vscode-sqlite) can be used to view the sqlite tables.

There exists all the in-built tables that django uses for the features django provides, and all our created tables as well.

> `django_migrations` table contains the data related to which migrations has been applied and when.

<br>

To see the actual sql code which is run by django to create the tables in the db:  
`sqlmigrate app_name XXXX`

> It depends on the current DB set in settings. (SQLite / PostgreSQL / etc.)

## Customizing Database Schema

When we create models, django uses a fixed convention to name the tables, etc.  
We can customize that using: `class Meta`  
https://docs.djangoproject.com/en/5.2/ref/models/options

We can change things like table name (using `db_table`), default ordering which applies when querying the data (using `ordering`), add indexes (using `indexes`), etc.

**Important:** We should avoid customizing for changing the naming conventions (unless there's a specific reasonn to do so), because we're using Django to speed-up our dev process. Django already defines good enough conventions, if we went to change them, we'd need to change for every model then to keep things streamlined across our project, so that's not very efficient. We should just use the default django naming conventions as much as possible.

> Note: When running `makemigrations`, it's generally recommended to make a single, logical set of changes to your models (e.g., adding a new feature, refactoring a specific part of a model) and then run `makemigrations`. If you have two unrelated or independently deployable changes to your models, it is better practice to make the first change, run `makemigrations` to create its dedicated migration file, commit it, and then make the other change, and run `makemigrations` again for its own migration. This approach results in clearer, more manageable, and easier-to-debug migration histories.

## Reverting Migrations

As we discussed before, migration files are like git commits, reverting migrations is the same concept as well.

If we made a mistake in the last migration(s), we can:
`migrate app_name XXXX` where XXXX is the migration id till which the code was correct.  
This would unapply all the migrations > XXXX.  
**But,** the model code and the migration files would still be there untouched, and hence when we'd do `migrate`, all the changes would come back again!  
Solution: Either we'd need to delete the migration files and revert all the model code manually, but better if we're tracking our code using git, we can `git reset --hard HEAD~1` to undo the last commit.

If we want to unapply only a single migration in the middle, we can only achieve that by manually undo-ing the model change, and then making a new migration.

## Installing ~~MySQL~~ PostgreSQL + Connecting to ~~MySQL~~ PostgreSQL

[Interactive installer by EDB](https://www.postgresql.org/download/macosx/#:~:text=Interactive%20installer%20by%20EDB) is useless.
- No convinient way to start/stop the server. (Requires a long cmd.)
- pgAdmin - Bad UI

<br>

Better:

Server: [Postgres.app](https://www.postgresql.org/download/macosx/#:~:text=Postgres.app) (Provides easy start/stop.)  
+  
DB IDE / DB Admin Tool / DB Client: [DataGrip](https://www.jetbrains.com/datagrip) (Paid, but free for students.)

<br>

In DataGrip:
1. Create / open a project (it's basically a dir)
2. Add Postgres as Data Source
3. Connect to the local db server using the server details / credentials
4. Create a new db

<br>

**DataGrip Alt:**

For small/basic work, just use VS code extenstion [SQL Tools](https://marketplace.visualstudio.com/items?itemName=mtxr.sqltools) which works very well!  
Requirement: VS code extenstion [SQLTools PostgreSQL Driver](https://marketplace.visualstudio.com/items?itemName=mtxr.sqltools-driver-pg)

## Using ~~MySQL~~ PostgreSQL in Django

https://docs.djangoproject.com/en/5.2/ref/databases/#postgresql-notes

Requirement: `psycopg`

```bash
pipenv install "psycopg[binary]"
```

<br>

https://docs.djangoproject.com/en/5.2/ref/settings/#databases:

```py
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "mydatabase",
        "USER": "mydatabaseuser",
        "PASSWORD": "mypassword",
        "HOST": "127.0.0.1",
        "PORT": "5432",
    }
}
```

And then `migrate` to create the tables in our new postgres db.

## Running Custom SQL

1. Make an empty migration file:

   ```bash
   makemigrations store --empty
   ```

2. There, in `operations` list, use:

   ```py
   migrations.RunSQL(sql, reverse_sql: Optional)
   ```

   If we don't provide `reverse_sql`, then we won't be able to undo the migration if we needed to using `migrate` cmd.

## Generating Dummy Data

https://www.mockaroo.com
