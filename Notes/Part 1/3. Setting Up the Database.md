## Supported Database Engines

https://docs.djangoproject.com/en/5.2/ref/databases

Default: SQLite - should only be used for development / personal projects with no traffic.

> SQLite is a serverless db.

For production, most popular: PostgreSQL, MySQL

> Mosh is using MySQL, but I'd use **Postgres** since it's **more popular** in Django.

## Creating Migrations

`makemigrations` - creates app-wise migration files using the current state of models in an app

Files are made with the name `XXXX_description.py` where XXXX is an ID starting with `0001`.  
The first file is made with name `0001_initial.py`.  
We can rename the file manually, but we must also rename all references to it from other migration files.  
Sometimes when the changes are not straightforward, Django cannot form a description string, so it creates the file with a vague name. In such cases, rename the file for better tracking.

Whenever `makemigrations` is done again, if there are changes, a new migration file is created.  
(Each migration file is like a commit in git.)

<br>

When a field (i.e., column) is added later in the model, there should be a value to populate all the existing records:

- Option 1: make the field nullable with `null=True`
- Option 2: add a default `default="something"`
- Option 3: supply a default value in the terminal (this is not saved in the model but only used for previous records and stored in the current migration file)

Choice depends on our requirements.

## Running Migrations

`migrate` - converts the migration files into actual SQL according to the current DB, and runs them to apply the changes in the DB

> VS Code extension [`sqlite`](https://marketplace.visualstudio.com/items?itemName=alexcvzz.vscode-sqlite) can be used to view the SQLite tables.

There exist all the in-built tables that Django uses for internal features, and all the user-created tables.

> The `django_migrations` table contains data related to which migrations have been applied and when. Django uses this table only to track which migrations have been applied.

<br>

To see the actual SQL that Django will run:

```bash
sqlmigrate app_name XXXX
```

> This depends on the current DB set in settings. (SQLite / PostgreSQL / etc.)

## Customizing Database Schema

When we create models, Django uses a fixed convention to name tables and fields.  
We can customize that using `class Meta`:  
https://docs.djangoproject.com/en/5.2/ref/models/options

We can change things like table name (using `db_table`), default ordering of querysets (using `ordering`), add indexes (using `indexes`), etc.

**Important:**
Avoid customizing just to change naming conventions (unless necessary). Django already provides good conventions.
If we override conventions for one model, we’d need to do it for all models to keep consistency, which is inefficient. It’s better to stick to Django’s defaults.

> Note: When running `makemigrations`, it's generally recommended to make a single, logical set of changes to your models (e.g., adding a new feature, refactoring a specific part of a model) and then run `makemigrations`. If you have two unrelated or independently deployable changes to your models, it is better practice to make the first change, run `makemigrations` to create its dedicated migration file, commit it, and then make the other change, and run `makemigrations` again for its own migration. This approach results in clearer, more manageable, and easier-to-debug migration histories.

## Reverting Migrations

As discussed before, migration files are like git commits. Reverting migrations follows a similar concept.

If a mistake is made in the last migration(s), we can run:

```bash
migrate app_name XXXX
```

where XXXX is the migration ID till which the code was correct.

This unapplies all migrations beyond XXXX.

**However**, the model code and the migration files would still be there untouched, and hence when we'd do `migrate`, all the changes would come back again!  
Solution: Either we'd need to delete the migration files and manually revert all the model code, but better if we're tracking our code using git, we can `git reset --hard HEAD~1` to undo the last commit.

If we want to unapply a migration in the middle of the chain, we must manually undo the model change and create a new migration file.

## Installing ~~MySQL~~ PostgreSQL + Connecting to ~~MySQL~~ PostgreSQL

[Interactive installer by EDB](https://www.postgresql.org/download/macosx/#:~:text=Interactive%20installer%20by%20EDB) is poor:

- No convenient way to start/stop the server (requires long command)
- pgAdmin has a bad UI

<br>

Better:

**Server:**
[Postgres.app](https://www.postgresql.org/download/macosx/#:~:text=Postgres.app) (Provides easy start/stop)  
\+  
**DB Client / DB Admin Tool:**
[DataGrip](https://www.jetbrains.com/datagrip) (Paid, but free for students)

<br>

Add `psql` to `PATH` (in `/Users/samyak/.zprofile`):

```bash
export PATH="/Applications/Postgres.app/Contents/Versions/17/bin:$PATH"
```

(This is the default install location on mac, change version if required.)

<br>

In DataGrip:

1. Create / open a project (basically a dir)
2. Add Postgres as Data Source
3. Connect to the local DB server using server details/credentials
4. Create a new DB

<br>

**DataGrip Alt:**

For small/basic tasks, just use VS Code extension [SQL Tools](https://marketplace.visualstudio.com/items?itemName=mtxr.sqltools), which works well!  
Requires: VS Code extension [SQLTools PostgreSQL Driver](https://marketplace.visualstudio.com/items?itemName=mtxr.sqltools-driver-pg)

## Using ~~MySQL~~ PostgreSQL in Django

https://docs.djangoproject.com/en/5.2/ref/databases/#postgresql-notes

Requirement: `psycopg`

```bash
pipenv install "psycopg[binary]"
```

<br>

https://docs.djangoproject.com/en/5.2/ref/settings/#databases:

```py
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "mydatabase",
        "USER": "mydatabaseuser",
        "PASSWORD": "mypassword",
        "HOST": "127.0.0.1",
        "PORT": "5432",
    }
}
```

And then `migrate` to create the tables in our new Postgres DB.

## Running Custom SQL

1. Make an empty migration file:

   ```bash
   makemigrations store --empty
   ```

2. There, in `operations` list, use:

   ```py
   migrations.RunSQL(sql, reverse_sql: Optional)
   ```

   If we don't provide `reverse_sql`, then we won't be able to undo the migration if we needed to using `migrate` cmd.

## Generating Dummy Data

[mockaroo.com](https://www.mockaroo.com)

> Run `seed.sql` given in the course to populate the data. (Delete all the previous data first.)

### Resetting auto-id

When we populates the data from outside, auto-id sequence may not be updated with the data, and `IntegrityError` arises while inserting a new record if the id pre-exists.

To solve this, update the id seq:

1. Make sure `psql` is added to `PATH`, check [above](/Notes/Part%201/3.%20Setting%20Up%20the%20Database.md#installing-mysql-postgresql--connecting-to-mysql-postgresql).

2. In the project path, do:

   ```bash
   python manage.py dbshell
   ```

3. Get the actual max id in the DB:

   ```bash
   SELECT MAX(id) FROM <app_name>_<modelname>;
   ```

4. Update:

   ```bash
   ALTER SEQUENCE <app_name>_<modelname>_id_seq RESTART WITH <max_id_from_above>+1;
   ```
