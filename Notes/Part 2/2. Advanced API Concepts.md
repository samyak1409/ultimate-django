## Class-based Views

Changing Function-based Views to Class-based Views.

We just need to convert the function to a class and move the code inside `if` blocks into respective methods of that class.

E.g.:

```py
class ProductList(APIView):

    def get(self, request):
        ...

    def post(self, request):
        ...
```

## Mixins

[django-rest-framework.org/api-guide/generic-views/#mixins](https://www.django-rest-framework.org/api-guide/generic-views/#mixins)

- ListModelMixin
- CreateModelMixin
- RetrieveModelMixin
- UpdateModelMixin
- DestroyModelMixin

## Generic Views

Instead of directly using the above mixins, we can use [Concrete View Classes](https://www.django-rest-framework.org/api-guide/generic-views/#concrete-view-classes), which combine one or more mixins.

E.g.:

```py
# Generic (`rest_framework.generics`) View:
class ProductList(ListCreateAPIView):

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    # Or we can use methods instead of above if we've some more logic or anything other than just a simple expression.
    # def get_queryset(self):
    #     return Product.objects.all()
    # def get_serializer_class(self):
    #     return ProductSerializer
```

Using Generic Views, code is much cleaner now, follows DRY, and also adds functionality like a form to POST data on the browsable API.

## Customizing Generic Views

We can inherit the class from the respective generic view and then override any method we want to.

See `store.views.ProductDetail`, `store.views.CollectionDetail`.

Read: [django-rest-framework.org/api-guide/generic-views/#examples](https://www.django-rest-framework.org/api-guide/generic-views/#examples)

## ViewSets

If we have a situation like this:

```py
class ProductList(ListCreateAPIView):

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

class ProductDetail(RetrieveUpdateDestroyAPIView):

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def delete(self, request, pk):
        product = get_object_or_404(Product, pk=pk)
        if product.orderitem_set.exists():  # custom behavior
            return Response(status=status.HTTP_409_CONFLICT)
        product.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
```

We should instead just use the cleaner `ModelViewSet`:

```py
class ProductViewSet(ModelViewSet):

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def destroy(self, request, *args, **kwargs):
        if OrderItem.objects.filter(product_id=kwargs["pk"]).exists():  # custom behavior
            return Response(status=status.HTTP_409_CONFLICT)
        return super().destroy(request, *args, **kwargs)
```

> If we want read-only behavior, we can use `ReadOnlyModelViewSet`.

ViewSets: [django-rest-framework.org/api-guide/viewsets](https://www.django-rest-framework.org/api-guide/viewsets)

## Routers

With viewsets, we use [Routers](https://www.django-rest-framework.org/api-guide/routers) to map the urls.

In `urls.py`:

```py
router = SimpleRouter()
router.register(prefix="products", viewset=views.ProductViewSet)
router.register(prefix="collections", viewset=views.CollectionViewSet)

urlpatterns = [
    ...
] + router.urls
```

Use [`DefaultRouter`](https://www.django-rest-framework.org/api-guide/routers/#defaultrouter) instead of [`SimpleRouter`](https://www.django-rest-framework.org/api-guide/routers/#simplerouter), adds two small features:

1. "API Root" endpoint e.g. [/store](http://127.0.0.1:8000/store)
2. For directly getting JSON data from any endpoint we had option to add `?format=json` (e.g. `/store/products?format=json`), now we can also do `.json` (e.g. `/store/products.json`)

##

> There are two main advantages of using a `ViewSet` class over using a `View` class.
>
> - Repeated logic can be combined into a single class. In the above example, we only need to specify the `queryset` once, and it'll be used across multiple views.
> - By using routers, we no longer need to deal with wiring up the URL conf ourselves.
>
> Both of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.
>
> \- [django-rest-framework.org/api-guide/viewsets/#example](https://www.django-rest-framework.org/api-guide/viewsets/#example)

## Building the Reviews API + Nested Routers

### [For Revision] Basic steps for making a REST API:

> BUILDING THE MODEL

1. Create a model class
2. Create a migration
3. Apply the migration

> BUILDING THE API

4. Create a serializer
5. Create a view
6. Register a route

<br>

**IMP:** See the code in `store.serializers.ReviewSerializer`, `store.views.ReviewViewSet` for:

1. Dynamic fetching of reviews based on current product id using `get_queryset`
2. On creation of a review, auto-adding of current product (which is a related field) based on the endpoint, using `get_serializer_context`, `create`

DRF Nested Routers: [django-rest-framework.org/api-guide/routers/#drf-nested-routers](https://www.django-rest-framework.org/api-guide/routers/#drf-nested-routers) > [github.com/alanjds/drf-nested-routers](https://github.com/alanjds/drf-nested-routers)

```sh
pipenv install drf-nested-routers
```

## Filtering

We can do three types of [Filtering](https://www.django-rest-framework.org/api-guide/filtering/#filtering):

- Filtering against the current user
- Filtering against the URL
- Filtering against query parameters

E.g., in `ProductViewSet`, we can do:

```py
    def get_queryset(self):
        collection_id = self.request.query_params.get("collection_id")
        if collection_id is not None:
            return Product.objects.filter(collection_id=collection_id)
        return Product.objects.all()
```

## Generic Filtering

[django-rest-framework.org/api-guide/filtering/#generic-filtering](https://www.django-rest-framework.org/api-guide/filtering/#generic-filtering)

[django-rest-framework.org/api-guide/filtering/#api-guide](https://www.django-rest-framework.org/api-guide/filtering/#api-guide)

1. ```sh
   pipenv install django-filter
   ```

2. `"django_filters"` -> `INSTALLED_APPS`

3. Add filter backend to `settings.py`:

   ```py
   REST_FRAMEWORK = {
       "DEFAULT_FILTER_BACKENDS": ["django_filters.rest_framework.DjangoFilterBackend"],
   }
   ```

4. For simple equality-based filtering, just set `filterset_fields` attribute on the view, or viewset:

   ```py
       filterset_fields = ["collection_id"]
   ```

### Advance Filtering

> For more advanced filtering requirements you can specify a `FilterSet` class that should be used by the view. You can read more about `FilterSet`s in the [django-filter documentation](https://django-filter.readthedocs.io/en/latest/index.html). It's also recommended that you read the section on [DRF integration](https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html).
>
> \- [django-rest-framework.org/api-guide/filtering/#djangofilterbackend](https://www.django-rest-framework.org/api-guide/filtering/#djangofilterbackend)

1. Define `<Model>Filter` in a new `filters.py`. (Check `store.filters.ProductFilter`.)

2. Replace `filterset_fields = [...]` with `filterset_class = <Model>Filter`.

This adds query params functionality (with GUI), e.g.:  
`/store/products/?collection_id=3&unit_price__gt=95&unit_price__lt=100`

## Searching

1. Add `"rest_framework.filters.SearchFilter"` to `settings.REST_FRAMEWORK."DEFAULT_FILTER_BACKENDS"`.

2. Add `search_fields = [...]` to view/viewset.

Notes:

- We can also use related fields using the good ol' d-under method, e.g. `"collection__title"`.
- By default, it's case-insensitive.

Read all details: [django-rest-framework.org/api-guide/filtering/#searchfilter](https://www.django-rest-framework.org/api-guide/filtering/#searchfilter)

## Sorting

[django-rest-framework.org/api-guide/filtering/#orderingfilter](https://www.django-rest-framework.org/api-guide/filtering/#orderingfilter)

(Same steps as [Searching](#searching). Read from above doc link.)

## Pagination

[django-rest-framework.org/api-guide/pagination/#pagination](https://www.django-rest-framework.org/api-guide/pagination)

[django-rest-framework.org/api-guide/pagination/#api-reference](https://www.django-rest-framework.org/api-guide/pagination/#api-reference)

Just adding following to `settings.REST_FRAMEWORK` enables beautiful pagination across the API:

```py
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 10,
```
