## Class-based Views

> Introduced **class-based views in DRF**: converting function-based views to `APIView` classes with `get`, `post`, `put`, `delete` methods, using `as_view()` in URLs, and showing benefits like cleaner code and OOP features.

Changing Function-based Views to Class-based Views.

We just need to convert the function to a class and move the code inside `if` blocks into respective methods of that class.

E.g.:

```py
class ProductList(APIView):

    def get(self, request):
        ...

    def post(self, request):
        ...
```

## Mixins

> Introduced **DRF mixins** (`ListModelMixin`, `CreateModelMixin`, etc.) to reuse common patterns like listing, creating, updating, and deleting resources instead of repeating code in class-based views.

[django-rest-framework.org/api-guide/generic-views/#mixins](https://www.django-rest-framework.org/api-guide/generic-views/#mixins)

- ListModelMixin
- CreateModelMixin
- RetrieveModelMixin
- UpdateModelMixin
- DestroyModelMixin

[Usage from next lecture.]

## Generic Views

> Explained **generic views in DRF**: concrete classes combining mixins (e.g., `ListCreateAPIView`, `RetrieveUpdateDestroyAPIView`) that reduce boilerplate by using `queryset` and `serializer_class` attributes, support overrides when needed, and simplify code while adding features like built-in forms in the browsable API.

Instead of directly using the above mixins, we use [Concrete View Classes](https://www.django-rest-framework.org/api-guide/generic-views/#concrete-view-classes), which combine one or more mixins. (Though we can also use the individual mixins directly when a concrete view class combined of required mixins is not there, see [Creating a Cart](/Notes/Part%202/3.%20Designing%20and%20Implementing%20a%20Shopping%20Cart%20API.md#creating-a-cart).)

E.g.:

```py
# Generic View:
class ProductList(ListCreateAPIView):

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    # Or we can use methods instead of above if we've some more logic or anything other than just a simple expression:
    # def get_queryset(self):
    #     return Product.objects.all()
    # def get_serializer_class(self):
    #     return ProductSerializer
```

Using Generic Views, code is much cleaner now, follows DRY, and also adds functionality like a `HTML form` with individual fields to POST data (alongside the existing `Raw data` form with a single `Content` field) on the browsable API.

## Customizing Generic Views

> Showed how to **customize DRF generic views** (e.g., `RetrieveUpdateDestroyAPIView`) by overriding methods like `delete` for app-specific logic, and explained handling `pk` vs `id` in URL patterns with `lookup_field`.

See `store.views.ProductDetail(RetrieveUpdateDestroyAPIView)`, `store.views.CollectionDetail(RetrieveUpdateDestroyAPIView)`.

Since we used `product = models.ForeignKey(to=Product, on_delete=models.PROTECT)` in `store.models.OrderItem`, if we don't explicitly prevent the deletion, our app would break because of `ProtectedError`. (Comment-out the overridden `delete()` and test.)

Read: [django-rest-framework.org/api-guide/generic-views/#examples](https://www.django-rest-framework.org/api-guide/generic-views/#examples)

And, `lookup_field`: [django-rest-framework.org/api-guide/generic-views/#attributes](https://www.django-rest-framework.org/api-guide/generic-views/#attributes:~:text=lookup_field)

- By default generic views expect `pk` as the lookup field URL param (`"products/<int:pk>/"`).
- If it is `id`, the default practice is to rename it to `pk` to follow conventions.
- But we can set e.g. `lookup_field = 'slug'` in the view to force it to look for `slug`.

## ViewSets

> Introduced **ViewSets** (`ModelViewSet` / `ReadOnlyModelViewSet`) to combine multiple related views (list, create, retrieve, update, delete) into a single class, reducing duplication.

If we have a situation like this:

```py
class ProductList(ListCreateAPIView):

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

class ProductDetail(RetrieveUpdateDestroyAPIView):

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def delete(self, request, pk):
        if OrderItem.objects.filter(product_id=pk).exists():
            return Response(status=status.HTTP_409_CONFLICT)
        return super().delete(request, pk)
```

We should instead just use the cleaner `ModelViewSet`:

```py
class ProductViewSet(ModelViewSet):

    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    def destroy(self, request, pk):
        if OrderItem.objects.filter(product_id=pk).exists():
            return Response(status=status.HTTP_409_CONFLICT)
        return super().destroy(request, pk)
```

If we want read-only behavior, we can use `ReadOnlyModelViewSet`.

ViewSets: [django-rest-framework.org/api-guide/viewsets](https://www.django-rest-framework.org/api-guide/viewsets)

> There are two main advantages of using a `ViewSet` class over using a `View` class.
>
> - Repeated logic can be combined into a single class. In the above example, we only need to specify the `queryset` once, and it'll be used across multiple views.
> - By using routers, we no longer need to deal with wiring up the URL conf ourselves.
>
> Both of these come with a trade-off. Using regular views and URL confs is more explicit and gives you more control. ViewSets are helpful if you want to get up and running quickly, or when you have a large API and you want to enforce a consistent URL configuration throughout.
>
> \- [django-rest-framework.org/api-guide/viewsets/#example](https://www.django-rest-framework.org/api-guide/viewsets/#example)

---

I still had some confusion between "[Concrete Generic Views](https://www.django-rest-framework.org/api-guide/generic-views/#concrete-view-classes)" and [`ModelViewSet`](https://www.django-rest-framework.org/api-guide/viewsets/#modelviewset), so I asked [Gemini](https://g.co/gemini/share/40308f1c97e6).  
TLDR: What benefit does ViewSets bring over GenericAPIViews? → Automatic routing.

## Routers

> Explained **routers** (`SimpleRouter` / `DefaultRouter`) to auto-generate URL patterns for viewsets, with `DefaultRouter` adding an API root page and `.json` responses.

With viewsets, we use [Routers](https://www.django-rest-framework.org/api-guide/routers) to map the urls.

In `urls.py`:

```py
router = SimpleRouter()
router.register(prefix="products", viewset=views.ProductViewSet)
router.register(prefix="collections", viewset=views.CollectionViewSet)

urlpatterns = [
    ...
] + router.urls
```

Use [`DefaultRouter`](https://www.django-rest-framework.org/api-guide/routers/#defaultrouter) instead of [`SimpleRouter`](https://www.django-rest-framework.org/api-guide/routers/#simplerouter), adds two small features:

1. "API Root" endpoint e.g. [/store](http://127.0.0.1:8000/store)
2. For directly getting JSON data from any endpoint we had option to add `?format=json` (e.g. `/store/products?format=json`), now we can also do `.json` (e.g. `/store/products.json`)

## Building the Reviews API

> Created the **Review model, serializer, and viewset** to enable product reviews, preparing for integration with **nested routers**.

### [Remember?] Basic steps for making a REST API:

**BUILDING THE MODEL**

1. Create a model class
2. Make & apply migrations

**BUILDING THE API**

3. Create a serializer
4. Create a view
5. Register a route

## Nested Routers

> Implemented **nested routers with DRF-Nested-Routers** for products and reviews, passing product ID via context and overriding `get_queryset` & `create` to properly filter and assign reviews to products.

**IMP:** See the code in `store.serializers.ReviewSerializer`, `store.views.ReviewViewSet` for:

1. Dynamic fetching of reviews based on current product id using `get_queryset`
2. On creation of a review, auto-adding of current product (which is a related field) based on the endpoint, using `get_serializer_context`, `create`

```py
    def create(self, validated_data):
        # return Review.objects.create(product_id=self.context["product_id"], **validated_data)
        return super().create(validated_data | {"product_id": self.context["product_id"]})
```

**Note:** Not sure what's the reason but Mosh taught the wrong way, we should not repeat the logic in the overridden method.  
**Read Gemini:** [Chat 1](https://g.co/gemini/share/4bfcb96cc571), [Chat 2](https://g.co/gemini/share/bd09cdc28393)

**DRF Nested Routers:** [django-rest-framework.org/api-guide/routers/#drf-nested-routers](https://www.django-rest-framework.org/api-guide/routers/#drf-nested-routers) > [github.com/alanjds/drf-nested-routers](https://github.com/alanjds/drf-nested-routers)

```sh
pipenv install drf-nested-routers
```

## Filtering

> Implemented **filtering products by collection ID** using `get_queryset()` with `request.query_params.get()`, and fixed base name issues by explicitly setting `basename` in the router.

We can do three types of [Filtering](https://www.django-rest-framework.org/api-guide/filtering/#filtering):

- Filtering against the current user (see `store.views.OrderViewSet.get_queryset`)
- Filtering against the URL (see `store.views.ReviewViewSet.get_queryset`)
- Filtering against query parameters (see below)

E.g., in `ProductViewSet`, we can do:

```py
    def get_queryset(self):
        collection_id = self.request.query_params.get("collection_id")
        if collection_id is not None:
            return Product.objects.filter(collection_id=collection_id)
        return Product.objects.all()
```

## Generic Filtering

> Implemented **generic filtering with Django-Filter**, including custom filters (e.g., unit price range), by creating a `ProductFilter` class and connecting it via `filterset_class` in the viewset.

[django-rest-framework.org/api-guide/filtering/#generic-filtering](https://www.django-rest-framework.org/api-guide/filtering/#generic-filtering)

[django-rest-framework.org/api-guide/filtering/#api-guide](https://www.django-rest-framework.org/api-guide/filtering/#api-guide)

1. ```sh
   pipenv install django-filter
   ```

2. `"django_filters"` -> `INSTALLED_APPS`

3. Add filter backend to `settings.py`:

   ```py
   REST_FRAMEWORK = {
       "DEFAULT_FILTER_BACKENDS": ["django_filters.rest_framework.DjangoFilterBackend"],
   }
   ```

4. For simple equality-based filtering, just set `filterset_fields` attribute on the view, or viewset:

   ```py
       filterset_fields = ["collection_id"]
   ```

### Advance Filtering

> For more advanced filtering requirements you can specify a `FilterSet` class that should be used by the view. You can read more about `FilterSet`s in the [django-filter documentation](https://django-filter.readthedocs.io/en/latest/index.html). It's also recommended that you read the section on [DRF integration](https://django-filter.readthedocs.io/en/latest/guide/rest_framework.html).
>
> \- [django-rest-framework.org/api-guide/filtering/#djangofilterbackend](https://www.django-rest-framework.org/api-guide/filtering/#djangofilterbackend)

1. Define `<Model>Filter` class in a new `filters.py`. (Check `store.filters.ProductFilter`.)

2. Replace `filterset_fields = [...]` with `filterset_class = <Model>Filter`.

This adds query params functionality (with a nice GUI button), e.g.:  
`/store/products/?collection_id=3&unit_price__gt=95&unit_price__lt=100`

## Searching

> Implemented **searching with DRF’s `SearchFilter`**, allowing case-insensitive keyword search on fields like `title` and `description` (with support for multiple terms). Parameter name: `search`.

1. Add `"rest_framework.filters.SearchFilter"` to `settings.REST_FRAMEWORK."DEFAULT_FILTER_BACKENDS"`.

2. Add `search_fields = [...]` to view/viewset.

Notes:

- We can also use related fields using the good ol' field lookup, e.g. `"collection__title"`.
- By default, it's case-insensitive.

Read all details: [django-rest-framework.org/api-guide/filtering/#searchfilter](https://www.django-rest-framework.org/api-guide/filtering/#searchfilter)

## Sorting

> Implemented **sorting with DRF’s `OrderingFilter`**, enabling ascending/descending and multi-field ordering (e.g., `unit_price`, `last_update`) via the `ordering` query parameter.

[django-rest-framework.org/api-guide/filtering/#orderingfilter](https://www.django-rest-framework.org/api-guide/filtering/#orderingfilter)

(Same steps as [Searching](#searching). Read from above doc link.)

## Pagination

> Implemented **pagination** using `PageNumberPagination` (with global or per-view settings), explored `LimitOffsetPagination`, and created a custom `DefaultPagination` class to set page size cleanly.

[django-rest-framework.org/api-guide/pagination/#pagination](https://www.django-rest-framework.org/api-guide/pagination)

[django-rest-framework.org/api-guide/pagination/#api-reference](https://www.django-rest-framework.org/api-guide/pagination/#api-reference)

Just adding following to `settings.REST_FRAMEWORK` enables beautiful pagination across the API:

```py
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",
    "PAGE_SIZE": 10,
```
