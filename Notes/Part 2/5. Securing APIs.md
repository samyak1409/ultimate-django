## Token-based Authentication

### Workflow

1. **Registration**

   - Client app sends user info (username, password, email, etc.) to `/users` endpoint.
   - Server creates a new user account.

2. **Login**

   - Client app sends credentials (username & password) to `/auth` endpoint.

   - Server validates credentials:
     - If invalid → returns error.
     - If valid → returns a **token**.

3. **Accessing Protected Resources**

   - Token acts as a **temporary key**.

   - Client stores token locally.

   - To access protected endpoints (e.g. `/me`):
     - Client sends token in the **request header**.
     - Server checks token:
       - If valid & not expired → access granted.
       - Else → error returned.

### Summary

- Token = session alternative for APIs.
- Server doesn't maintain session state.
- Used in **REST APIs** for secure, stateless communication.

<details>
<summary>Read more (1)</summary>

#### 1. **Token = session alternative for APIs**

In traditional web applications (like those using Django templates), when a user logs in:

- The server creates a **session** and stores it (usually in memory or a database).
- It also sends a **session ID** (like a cookie) to the browser to identify that session on future requests.

**In REST APIs**, instead of using server-stored sessions:

- The server gives a **token** (usually a string) after successful login.
- This token is like a digital key — it proves the user is authenticated.
- The client (like a mobile app or frontend) **stores this token locally** (in local storage, memory, etc.).

So:

> **Token replaces sessions in REST API-based apps.**

#### 2. **Server doesn't maintain session state**

"Session state" means the server _remembers_ which user is logged in by keeping track of session data.

In token-based systems:

- **Server doesn't store anything about logged-in users.**
- The **token carries all necessary info** to identify the user.
- The server simply **verifies the token** on each request.

This is what we call a **stateless system**.

> Every request is independent; the server treats it like a fresh request and uses the token to authenticate.

#### 3. **Used in REST APIs for secure, stateless communication**

REST APIs are designed to be **stateless** — meaning the server shouldn’t keep track of any client state between requests.

Token-based auth aligns perfectly with this principle:

- **Stateless**: Server doesn’t store user sessions.
- **Secure**: Tokens can be encrypted/signed and expire after some time.
- **Scalable**: Since the server doesn’t store session data, it's easier to scale horizontally (across multiple servers).

</details>

<details>
<summary>Read more (2)</summary>

### Why APIs use tokens instead of sessions, especially in stateless systems

#### 1. First, the key difference: **Sessions vs Tokens**

- **Sessions**

  - Server creates a “session” after you log in.
  - Server stores your data (e.g., user ID, roles) in memory or a DB.
  - Browser gets a **session ID** (usually in a cookie) that it sends with each request.
  - Server looks up the session in its storage to know who you are.

- **Tokens (JWT, etc.)**

  - Server creates a signed piece of data containing your identity & permissions.
  - Token itself contains all info needed — no server lookup.
  - Sent in `Authorization` header (or similar) with every request.
  - Server just verifies the token’s signature to trust it — **no session storage**.

#### 2. Why tokens are better for **stateless APIs**

REST APIs are **stateless** → each request must be **self-contained** (server doesn’t remember previous requests).
This means:

- The server should **not have to store client state** between requests.
- Each request must contain all info needed for authentication.

**Sessions break statelessness** because:

- They require the server to store a record of your session.
- If you scale horizontally (multiple servers), every server needs access to the same session store → extra complexity.

**Tokens fit statelessness** because:

- All necessary info is inside the token itself.
- Server only needs its secret key to validate → no extra lookup.
- Scaling is easy — any server can validate the token.

#### 3. Concrete example

**Session approach**:

1. You log in → server stores `{ session_id: 12345, user_id: 42 }` in Redis.
2. Every request → client sends `session_id=12345`.
3. Server has to **look up session_id in Redis** → find user_id → proceed.

**Token approach**:

1. You log in → server creates a JWT:

   ```
   {
     "user_id": 42,
     "role": "admin",
     "exp": 1723567200
   }
   ```

   Signed with server’s private key.

2. Every request → client sends `Authorization: Bearer <token>`.
3. Server verifies signature → instantly knows user_id & role — no DB/Redis call.

#### 4. The **"WHY"** boiled down to a sentence

We use **tokens** in stateless APIs because they **remove the need for server-side session storage**, making it easier to scale, keeping each request independent, and aligning perfectly with the stateless nature of REST.

#### 5. Bonus: When sessions might still be better

- Small apps where scaling isn’t an issue.
- You want easy revocation (revoke) of logins without complex token blacklisting.
- Browser-based apps that benefit from cookie-based auth.

</details>

<details>
<summary>Read more (3)</summary>

### Why this is done (benefits):

#### 1. **Scalability**

- If the server doesn't have to remember the state of every connected client, it can serve many more clients at once.
- Any request can be sent to **any server in a cluster**, because no server is holding "your" session data in memory.
- This makes **load balancing** simple and effective.

#### 2. **Reliability & Failover**

- If a server fails, the client can send the next request to another server and it will work, because no server needs to remember what happened earlier.
- There’s no “session loss” problem — state is on the client side.

#### 3. **Simplicity**

- No need for complex session management logic on the backend.
- The server just processes requests independently, making the API easier to develop and maintain.

#### 4. **Caching**

- Since requests are independent, responses can be cached at various points (browser, CDN, reverse proxy) without worrying about user-specific server state.
- This reduces latency and improves performance.

#### 5. **Interoperability**

- Statelessness makes APIs more predictable, which is critical for integration with diverse systems and clients.

**In short:**
Statelessness in REST makes APIs **scalable, fault-tolerant, simpler, and faster** by ensuring that the client carries the state, not the server.

</details>

<br>

> Next, we would demonstrate this flow in action.

## Adding the Authentication Endpoints

### Why Djoser?

- Django has a built-in authentication system but **no API layer**.

- [Djoser](https://djoser.readthedocs.io) is a RESTful implementation of (or REST API around) Django’s auth system.

- Provides endpoints for:

  - User registration
  - Login / Logout
  - Password reset
  - Retrieve current user

- Saves time by avoiding need of manual implementation in every project.

### Installation & Setup

[Read the Docs](https://djoser.readthedocs.io/en/latest/getting_started.html#installation)

1. ```sh
   pipenv install djoser
   ```

2. Add `"djoser"` to `INSTALLED_APPS`.

3. Register authentication routes in the main `urls.py`:

   ```py
   path("auth/", include("djoser.urls")),
   ```

4. **[Authentication Backend](https://djoser.readthedocs.io/en/latest/authentication_backends.html)**:

   - **Option 1:** Token Based Authentication (DB lookup for every request).

     - Tokens stored in a dedicated DB table.
     - Requires DB query per request.

   - **Option 2 (Preferred):** JSON Web Token Authentication (no DB lookup, uses digital signature).

     - Self-contained, signed tokens.
     - Validated without DB query.

### JWT Authentication Setup

1. ```sh
   pipenv install djangorestframework_simplejwt
   ```

2. [See](https://djoser.readthedocs.io/en/latest/authentication_backends.html#json-web-token-authentication)

## Registering Users

- Client sends `POST` request to `/users` with:

  - `email`
  - `username`
  - `password`

- Password validators in `settings.AUTH_PASSWORD_VALIDATORS`:

  - **UserAttributeSimilarityValidator** → Prevents password similar to username.
  - **MinimumLengthValidator** → Enforces minimum length.
  - **CommonPasswordValidator** → Blocks common passwords.
  - **NumericPasswordValidator** → Prevents purely numeric passwords.

### Adding Extra Fields

- Registration form fields are based on a serializer (`UserCreateSerializer` in Djoser).

- To add extra fields:

  1. Create **custom serializer** extending Djoser’s `UserCreateSerializer`.

  2. Override `Meta.fields` to include the extra fields (e.g. `first_name`, `last_name`).

  3. Add in `settings.DJOSER`:

     ```py
         'SERIALIZERS': {
             'user_create': 'core.serializers.CustomUserCreateSerializer',
         }
     ```

[Docs](https://djoser.readthedocs.io/en/latest/settings.html#serializers)

### Adding Profile Data (e.g., `birth_date`)

- **Bad approach**: Add profile fields directly into `CustomUserCreateSerializer` and save in same request (modify the save method of `CustomUserCreateSerializer` to save `user` object as well as `profile` object).

  - Violates **Single Responsibility Principle**.

  - Leads to tightly coupled, hard-to-maintain code.

- **Good approach**:

  - Keep `CustomUserCreateSerializer` only for user model fields.

  - Capture `birth_date` in separate **Profile API** (`/customers`).

  - Client: User creation form would show the fields from both the models, and two subsequent requests would be sent:

    1. `POST /users` → Create user account.
    2. `POST /customers` → Save profile-related fields.

**Key Principle**

> Each endpoint should have **one responsibility** → keeps APIs reusable, maintainable, and avoids "spaghetti code."

## Building the Profile API

- **Djoser** handles **user authentication** and user-related endpoints.
- It **does not** provide profile/customer endpoints (profiles are app-specific).
- Example: `company` app has a `Employee` model → API for this must be custom-built.

### Steps to Implement

In the `store` app (where `Customer` model is):

#### 1. Serializer

```py
class CustomerSerializer(serializers.ModelSerializer):
    class Meta:
        model = Customer
        fields = ['id', 'phone', 'birth_date', 'membership']
```

#### 2. ViewSet

```py
class CustomerViewSet(
    CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet
):

    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer
```

- **Not** using `ModelViewSet` because:

  - No `list` needed (only in admin).
  - No `destroy`, customer will be deleted when user deleted (`on_delete=models.CASCADE`).

#### 3. URLs

```py
router.register(prefix='customers', viewset=views.CustomerViewSet)
```

<br>

**Note:** Once endpoint is secured:

- Client sends token.
- Server extracts `user_id` from token.
- No need to send `user_id` in request body.

## Logging In

### JWT Endpoints

- `/auth/jwt/create` → Login (POST only)
- `/auth/jwt/refresh` → Get new access token
- `/auth/jwt/verify` → Verify token

### Login Process

1. **POST** to `/auth/jwt/create` with username + password.

2. On success → Receive:

   - **Access Token**: Short-lived (default 5 min) → Used for secure API calls.
   - **Refresh Token**: Longer-lived (default 1 day) → Used to get new access tokens.

3. Default lifetimes can be overridden in `settings.py`:

   ```py
   SIMPLE_JWT = {
       "ACCESS_TOKEN_LIFETIME": timedelta(days=1),
   }
   ```

   [Docs](https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html)

### Token Storage [Client]

- **Web Apps**: Stored in browser's local storage.
- **Mobile Apps**: Stored using platform-specific local storage APIs.

### Logout

- Simply **remove token** from client storage. (**Client would do it.**)
- No logout endpoint needed (as tokens not stored in DB).

## Inspecting a JSON Web Token

Official site: [jwt.io](https://jwt.io)

### **Structure of a JWT**

1. **Header**

   - JSON object: `{"typ": "JWT", "alg": "HS256"}`
   - Contains type of token & signing algorithm.

2. **Payload**

   - JSON object with claims, e.g.:

     - `token_type`: `"access"` or `"refresh"`
     - `exp`: Expiration time
     - `iat`: Issued at
     - `jti`: Unique token ID
     - `user_id`: ID of authenticated user (for our token we got from `/auth/jwt/create`)

3. **Signature**

   - Created from **Header + Payload + Secret** (django secret key) using the specified algorithm.
   - Ensures integrity: any change to Header/Payload invalidates signature.

### **How It’s Created**

1. User logs in with valid credentials.
2. Server fetches user data (e.g., `user_id`, ...).
3. Creates Header & Payload.
4. Generates Signature using a **server-only secret**.

### **Security**

- If token is modified (e.g., `user_id` changed), signature no longer matches → token is rejected.
- Hackers **cannot** regenerate signature without the server’s secret key.
- Secret must remain secure on the server.

> The reason why `settings.SECRET_KEY` **must not** be pushed to GitHub.

## Refreshing Tokens

- **Accessing protected endpoints**:

  - Client sends **Access Token** in request header.
  - If token expired → server responds with **401 Unauthorized**.

- **Refreshing tokens**:

  - Client calls `/auth/jwt/refresh` endpoint with **Refresh Token**.
  - Server issues a **new Access Token**, and the intended endpoint is called again.

  > Note:
  >
  > 1. This all happens without the user knowing.
  > 2. If refresh token is expired as well, **then** user needs to login with the password again.

## Getting the Current User

- **Endpoint**: `/auth/users/me`

  - Returns current user's data.
  - Requires **Access Token** in the request header.
  - Without token → `401 Unauthorized`.

- **Sending Access Token**:

  - Use browser extensions (e.g., **[ModHeader](https://chromewebstore.google.com/detail/idgpnmonknjnojddfkpgkljpfnnfcklj)**) to modify HTTP headers.
  - Header format:
    ```
    Authorization: JWT <access_token>
    ```
    (Prefix `"JWT"` as set in Django settings.)

- **Customizing returned fields**:

  - Same process as above `Adding Extra Fields` section.

## Getting Current User's Profile

**Adding New Endpoint**: `/store/customers/me`

- Implemented as a **custom action** in `CustomerViewSet` using `@action` decorator from DRF.
- `detail=False` → so it's only available on list view (`/store/customers/me`) and not detail view (`/store/customers/<id>/me`).
- `methods=["GET", "PUT"]` so it supports `GET` and `PUT` methods.

See the code in `store.views.CustomerViewSet.me()`.

> **Note:** `request.user` comes from Django's authentication middleware:
>
> - If logged in → `User` object.
> - If not → `AnonymousUser`. (And if we do `.id` on this object, it's `None`)

So, now:

- **GET `/store/customers/me`** → Returns current user's customer profile.
- **PUT `/store/customers/me`** → Updates allowed fields (`phone`, `birth_date`, `membership`).

## Applying Permissions

### Built-in Permission Classes

[See DRF Docs](https://www.django-rest-framework.org/api-guide/permissions/#api-reference)

- **AllowAny** – Default; all endpoints accessible without login.
- **IsAuthenticated** – Only authenticated users can access.
- **IsAdminUser** – Only admin users can access.
- **IsAuthenticatedOrReadOnly** – Read allowed for all; write allowed for authenticated users.
- We can also **create custom permission classes**.

### Applying Permissions

#### 1. **Globally (in `settings.py`)**

```py
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ]
}
```

- Affects all endpoints.
- Can still **override per view**.

#### 2. **Per View/ViewSet**

```py
from rest_framework.permissions import IsAuthenticated

class CustomerViewSet(...):

    ...

    permission_classes = [IsAuthenticated]
```

- List can contain multiple permission classes.
- **All must pass** for access to be granted.
- Can still **override per action**.

#### 3. **Per Action**

```py
from rest_framework.permissions import IsAuthenticated

class CustomerViewSet(...):

    ...

    @action(..., permission_classes = [IsAuthenticated])
    def me(...):
        ...
```

#### 4. **Different Permissions for Different HTTP Methods**

Override `get_permissions()` method:

```py
from rest_framework.permissions import AllowAny, IsAuthenticated

class CustomerViewSet(...):

    ...

    def get_permissions(self):
        if self.request.method == 'GET':
            return [AllowAny()]
        return [IsAuthenticated()]
```

Notice:

- `permission_classes` attribute → list of **classes**.
- `get_permissions()` method → list of **instances** (objects).

## Applying Custom Permissions

**Problem**: Products endpoint was open to everyone; needed to restrict modifications to admins while allowing read access to anyone (including anonymous users).

**Built-in Limitation**: DRF provides `IsAuthenticatedOrReadOnly` but no direct `IsAdminOrReadOnly` permission.

**Solution**: Create a **custom permission**.

### Custom Permission Creation

1. Create `permissions.py` in the app.
2. Define class `IsAdminOrReadOnly(permissions.BasePermission)`:

   In `has_permission()`:

   - Allow request if `request.method` is in `permissions.SAFE_METHODS` (`GET`, `HEAD`, `OPTIONS`).
   - Otherwise, allow only if `request.user` is not None **and** `request.user.is_staff` is `True`.
   - (Followed the similar pattern as `BasePermission` classes in `rest_framework.permissions`, like `IsAuthenticated`, `IsAdminUser`, etc.)

   > `request.user` is redundant in the statement `return request.user and request.user.is_staff`, right?  
   > Wrong. Read 3rd point ("3. Why the Safeguard is Necessary") in first response in [Gemini](https://g.co/gemini/share/c7984244a80f).

3. Apply this permission to relevant viewsets:

   - **Products**: `permission_classes = [IsAdminOrReadOnly]`.

   - **Collections**: same as products.

   - **Shopping Carts**: no permission restrictions (anonymous allowed).

   - **Customers**:

     - Switch to `ModelViewSet` for full CRUD.
     - Default `permission_classes = [IsAdminUser]` (admins manage customers).
     - Override for specific actions like `retrieve` current profile (`/store/customers/me`) with `IsAuthenticated`.

### Outcome

- Anonymous users: Can only read products/collections, create shopping carts, but cannot modify data.
- Authenticated non-admin users: Can access their own profile.
- Admin users: Full access to products, collections, customers.

## Applying Model Permissions

Currently, **all admin (`is_staff`) users** can manage customers via the `customers` endpoint.

But as you might remember, in [4. Django Authentication System > Groups and Permissions](https://github.com/samyak1409/ultimate-django/blob/main/Notes/Part%202/4.%20Django%20Authentication%20System.md#groups-and-permissions), we created a `Customer Service` group in Django admin.

To allow only the users in this group to access `customers` endpoint, we can use `permissions.DjangoModelPermissions`.

### How `DjangoModelPermissions` Works

`DjangoModelPermissions` has:

```py
    perms_map = {
        'GET': [],
        'OPTIONS': [],
        'HEAD': [],
        'POST': ['%(app_label)s.add_%(model_name)s'],
        'PUT': ['%(app_label)s.change_%(model_name)s'],
        'PATCH': ['%(app_label)s.change_%(model_name)s'],
        'DELETE': ['%(app_label)s.delete_%(model_name)s'],
    }
```

Maps **HTTP methods** to **required model permissions**:

- `GET`, `OPTIONS`, `HEAD` → No permission required by default.
- `POST` → `add` permission.
- `PUT`, `PATCH` → `change` permission.
- `DELETE` → `delete` permission.

These `add`, `change`, `delete`, `view` permissions are [Built-in Permissions](https://github.com/samyak1409/ultimate-django/blob/main/Notes/Part%202/4.%20Django%20Authentication%20System.md#built-in-permissions).

### Outcome

Now, using **`DjangoModelPermissions`** in `CustomerViewSet`:

- Requires user to (be **authenticated** and) have **those model permissions** on `customers` endpoint.

So:

- Any (authenticated) user in `Customer Service` group: Can create, update, delete customers.
- Any other authenticated user: Can **view** customers.
- And, anonymous users: **`401 Unauthorized`**

### Adding View Permission

We don't want this:

> Any other authenticated user: Can **view** customers.

So, we can create **custom permission class** extending `DjangoModelPermissions`:

- Override `perms_map['GET']` to require `view` permission.

> See `store.permissions.FullDjangoModelPermissions`.

Now, even authenticated user but not in the group get: **`403 Forbidden`**

<br>

> Like `DjangoModelPermissions`, one more class is **`DjangoModelPermissionsOrAnonReadOnly`**: Same as `DjangoModelPermissions` but allows **anonymous read-only access**.

## Applying Custom Model Permissions

> This is very powerful/useful!

Suppose, we want to have an endpoint `/store/customers/<id>/history` for something (that doesn't matter for now).  
And, we want only selected users to have the permission to access these endpoints.  
We can achieve this by following.

### Custom Model Permission

So, first we need to do this: [Creating Custom Permissions](https://github.com/samyak1409/ultimate-django/blob/main/Notes/Part%202/4.%20Django%20Authentication%20System.md#creating-custom-permissions)

<details>
<summary>See</summary>

- Define in model’s `Meta` class via `permissions` list of tuples:

  - Format: `('code_name', 'Description')`
  - Example: `('view_history', 'Can view history')`

- Run:

  - `python manage.py makemigrations`
  - `python manage.py migrate`

</details>

### Custom Action in ViewSet

- Add method (e.g., `history(self, request, pk)`).
- Decorate with `@action(detail=True)`.
- Return simple `Response` for testing.

> See `store.views.CustomerViewSet`.

### Permission Class

- In `permissions.py`, extend `BasePermission`.
- Override `has_permission()`:

  ```py
  return request.user.has_perm("store.view_history")
  ```

> See `store.permissions.ViewCustomerHistoryPermission`.

- Use `permission_classes=[ViewCustomerHistoryPermission]` in `action()` decorator.

> **ALSO, VERY IMPORTANT NOTE:**  
> Superuser status: Designates that this user has all permissions without explicitly assigning them.

### Assigning Permissions [Best Practice]

In admin panel:

- Avoid adding permissions to individual users.

- Use **groups**:

  - Add permissions to groups.
  - Add users to groups.
  - Groups allow easy tracking and filtering; permissions do not.
