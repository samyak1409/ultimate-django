## Designing the API

- **POST /orders**

  - Request body: only `cart_id`.
  - User ID is extracted from JWT in the request header.
  - Creates an order object and returns it.
  - **Access**: Authenticated users only.

- **GET /orders**

  - Regular user: sees only their own orders.
  - Admin: sees all orders.

- **GET /orders/{id}**

  - Same policy: users see only their own order unless admin.

- **PATCH /orders/{id}**

- **DELETE /orders/{id}**

## Getting the Orders

- **Start with "Get Orders" endpoint** (simpler than creating orders).

- Initially: no permissions, just return all orders with details.

- **OrderSerializer**: fields → `id`, `customer`, `placed_at`, `payment_status`.

- **OrderViewSet**: subclass `ModelViewSet`; queryset → `Order.objects.all`; serializer → `OrderSerializer`.

- **URL Registration**: register endpoint for managing orders.

<br>

- **OrderItem Serializer**: fields → `id`, `product`, `quantity`, `unit_price`; exclude `order`.

- Add `orderitem_set` field in `OrderSerializer` using `OrderItemSerializer(many=True)`.

- Nest product data in order items using existing `SimpleProductSerializer`.

- Result: API returns orders with nested order items and product details.

<br>

**Avoid N-queries:**

Mosh skipped checking the debug toolbar for number of queries, I checked and found out N-queries problem was indeed there (n = number of products).  
Since we're using `orderitem_set = OrderItemSerializer()` in `OrderSerializer`, and `product = SimpleProductSerializer()` in `OrderItemSerializer`.

**Solution:**

```py
    queryset = Order.objects.prefetch_related('orderitem_set__product')
    # Instead of just:
    # queryset = Order.objects.all()
```

See: [Gemini](https://g.co/gemini/share/4df3eff5c2ea)

## Applying Permissions

- **Currently:** Orders endpoint open to everyone, including anonymous users.

- **Fix 1:** Add `IsAuthenticated` permission class to the viewset → only logged-in users can access.

- **Fix 2:** Return queryset based on role:

  - **Admin (`is_staff`)** → can see all orders.
  - **Non-admin** → can only see their own orders.

- **Implementation:**

  - Override `get_queryset()`.
  - For non-admins, get `customer_id` using `user.id` (via `Customer` model) and filter orders.
  - Small optimization: use `.only("id")` to fetch just `id`.

  > See `store.views.OrderViewSet`.

  - (**Note:** As you might remember, removing `queryset` requires explicitly setting `basename` in router registration.)

## Creating an Order

We need a new serializer.

- **Reason:**

  - Only need to send `cart_id` when creating an order.
  - Shape of request data differs from existing `OrderSerializer`.
  - `cart_id` not a field in `Order` model → can't use `ModelSerializer`.

- **Implementation:**

  1. **Create `CreateOrderSerializer`** (inherits from `Serializer`, not `ModelSerializer`).

     - Define `cart_id` as a UUID field.

  2. **Override `save()`** — custom logic for creating orders.

  3. **Pass `user_id` to serializer via context**:

     - Override `get_serializer_context()` in viewset → `{"user_id": self.request.user.id}`.

  4. **Select serializer dynamically**:

     - Override `get_serializer_class()` → use `CreateOrderSerializer` for `POST`, `OrderSerializer` otherwise.

- **Creating an order in `save()`**:

  - Get `user_id` from `self.context["user_id"]`.
  - Get `customer` for this `user_id`.
  - Create `Order` with `customer.id`.

- **Testing:**

  - Create a cart, copy its ID, post to orders endpoint.
  - Confirm in DB: new order created for current customer.

## Creating Order Items

1. **Retrieve cart items**

   - `CartItem.objects.filter(cart_id=self.validated_data["cart_id"])`
   - Use `.select_related("product")` to avoid extra DB queries.

2. **Convert cart items → order items**

   ```py
    order_items = [
        OrderItem(
            order_id=order.id,
            product_id=cart_item.product_id,
            quantity=cart_item.quantity,
            unit_price=cart_item.product.unit_price,
        )
        for cart_item in cart_items
    ]
   ```

3. **Bulk insert order items**

   - `OrderItem.objects.bulk_create(order_items)` (avoids multiple DB hits).

4. **Delete the cart after order creation**

   - `Cart.objects.get(pk=cart_id).delete()`

### Ensuring Data Consistency

- **Problem:**

  Multiple DB operations → risk of inconsistent state if a DB failure occurs mid-process.

- **Solution:**

  Use a **transaction** so operations are atomic:

  ```py
  from django.db import transaction
  with transaction.atomic():
      # Create order
      # Create order items
      # Delete cart
  ```

  If any step fails → all changes rolled back.

### Result

- Orders and their items are created in bulk efficiently.
- Shopping cart is removed after successful order creation.
- Database remains consistent due to transaction handling.

> I think we should use [Signals](#signals) here as well (like we did (in the end of this section) to create a customer when an user is created instead of putting the customer creation code in user serializer) to adhere to [SOLID's Single responsibility principle](https://en.wikipedia.org/wiki/SOLID#Single_responsibility_principle).

## Returning the Created Order

- **Problem**: Posting `cart_id` to the server (`/store/orders`) returns the same `cart_id` instead of an order object.

- **Cause**:

  - Default `create` method in `CreateModelMixin` uses the same serializer for both input and output.
  - The serializer only has `cart_id` → output `cart_id`.

- **Solution**:

  - **Override** the `create` method in the viewset.

  - Use **two serializers**:

    - **Input serializer** (`CreateOrderSerializer`) → to deserialize and validate `cart_id`.
    - **Output serializer** (`OrderSerializer`) → to serialize and return the created order.

  - Modify `save()` in serializer to **return the created order object**.

  - Pass **context** (`user_id`) directly when initializing input serializer in `create()`. (Remove `get_serializer_context` method.)

API now returns a proper order object with its ID instead of just `cart_id`.

## Data Validation

Two invalid scenarios to handle:

1. **Invalid cart ID** – cart doesn’t exist.
2. **Empty cart** – no items in cart.

**Solution:**

Add a **`validate_cart_id`** method in serializer.

- **1:** Check if cart doesn't exist and raise `serializers.ValidationError`.

- **2:** Check if cart items doesn't exist and raise `serializers.ValidationError`.

- Return `cart_id` if valid.

> See the code `store.serializers.CreateOrderSerializer.validate_cart_id`.

> Note: `exists()` is the fastest way to check existence of records.
>
> "This tries to perform the query in the simplest and fastest way possible" - [Official Django Docs](https://docs.djangoproject.com/en/5.2/ref/models/querysets/#django.db.models.query.QuerySet.exists)
>
> "It's the most efficient and readable." - [Gemini](https://g.co/gemini/share/8bcd95d46640)

**Testing:**

- Invalid cart ID → Returns `400 Bad Request` with error message.
- Empty cart → Returns `400 Bad Request` with error message.

<br>

<details>
<summary>Best Practice Highlight</summary>

- Build in stages:

  1. Implement happy path.
  2. Improve and refactor.
  3. Add validation.

- Avoid doing too many things at once.

</details>

## Revisiting the Permissions

**Currently**, customers can update/delete their orders — not desired.

Restrict order modification permissions so only admins can update or delete orders:

1. **Override** `get_permissions()` in the viewset instead of using `permission_classes`.

2. Logic:

   - If `request.method` is in `['PATCH', 'DELETE']` → return `[IsAdminUser()]`.
   - Else → return `[IsAuthenticated()]`.

3. Restrict `http_method_names` to `['post', 'get', 'patch', 'delete', 'head', 'options']`.

> Mosh mistakenly missed `'post'` in `http_method_names`.

## Updating an Order

**Goal:** Allow only `payment_status` to be updated in an order; all other fields (order time, customer, items) must remain unchanged.

**My Approach (Problematic):**

- Add `read_only_fields = ["placed_at", "customer"]` in `OrderSerializer.Meta`.
- Add `read_only=True` in `OrderSerializer.OrderItemSerializer()`.

Problem:  
In the `Content` input field on browsable API, instead of JSON with just `payment_status`, JSON with absolutely all the fields (like there with `GET`) is coming pre-filled. **Though change is being saved only for the `payment_status` field**, even if I change any other field, it's not being actually reflected, and without any error, with `200 OK`.  
Here, we're talking about `PUT`/`PATCH` (i.e. on `/store/orders/<id>` pages). If I try with `POST` (i.e. on `/store/orders`) (by uncommenting our currently used `CreateOrderSerializer` from `OrderViewSet.get_serializer_class()`), then it's working correctly! (Just like it works in `CartSerializer`.)  
Also, note that we're only using `PATCH` (by disallowing `PUT` through `http_method_names`) since we've only one field to update, but if we replace `PATCH` with `PUT`, then browsable API's `HTML form` shows up as well (this feature BTW isn't available with `PATCH` for some reason), which indeed shows just `payment_status`!! (while `Content` input box of `Raw data` form still shows all the fields.)

Here're the reasons (Gemini) (Just read TLDR sections): [Try 1](https://g.co/gemini/share/3ae214c96628), [Try 2](https://g.co/gemini/share/f092feaa999d) (Got same answers)  
Conclusion as far as my understanding goes: It boils down to DRF's implementation. They could've improved it to eliminate above issue(s) by:

- Taking read only settings in account to not include those fields in `Content` input box, just like they're already doing in `HTML form` with `PUT`.
- Show `HTML form` with `PATCH` as well: Show all the writable fields just like done with `PUT`, but send only those fields in the request whose values are changed. Improve UX by making this evident by keeping all the fields a bit faded initially, then making opacity normal if a field is changed. (If a field is changed back to the current value, fade it back.)

<br>

**Mosh's Approach:**

- Create a dedicated `UpdateOrderSerializer`.

- `Meta`:

  - `model = Order`
  - `fields = ['payment_status']`

- Override `get_serializer_class` to return `UpdateOrderSerializer` when request method is `PATCH`.

**Result:** When updating (`PATCH`), only `payment_status` is shown and can be changed.

## Signals

> **Decoupling responsibilities**

**Requirement:**

We want `Customer` to automatically be created when `User` is created.

**Initial Fix (not ideal):**

- Override `save()` in `core.serializers.CustomUserCreateSerializer` to create a `Customer` when a `User` is saved.
- Drawback: Serializer becomes overloaded with responsibilities → harder to maintain.

**Better Fix – Use Signals:**

- Django provides signals like `pre_save`, `post_save`, `pre_delete`, `post_delete`, and so on, to trigger actions at specific model lifecycle events.

- Current issue:

  - In `core` app, `UserCreateSerializer` handles **both** user creation and customer creation → mixes responsibilities.

- Proposed improvement:

  - Move customer creation logic to `store` app by **listening to the `post_save` signal** of the `User` model.
  - When a user is created, the signal handler in `store` automatically creates the corresponding `Customer` record.

- Benefit:

  - Responsibilities are better distributed between apps.
  - The `core` app focuses only on user creation; the `store` app handles customer creation.

1. **Create `signals/handlers.py` in `store` app**:

   - Define function `create_customer_for_new_user(sender, **kwargs)` (signal handler).
   - Check `if kwargs['created']:` → create a `Customer` linked to the new `User`.

2. **Use `@receiver(post_save, sender=settings.AUTH_USER_MODEL)`**:

   - (Again, remember to use `settings.AUTH_USER_MODEL` to avoid hard dependency on `core` app.)

3. **Activate signal**:

   - In `store/apps.py`, override `ready()` → add `from .signals import handlers`.

## Creating Custom Signals

- Every Django model fires built-in signals (e.g., `post_save`), but we can also create **custom signals** for app-specific events.
- Example: Fire an `order_created` signal manually whenever a new order is placed in the **store** app.

**Implementation:**

1. **Instantiate signal object**:

   - In `signals/__init__.py`:

     ```py
     from django.dispatch import Signal
     order_created = Signal()
     ```

2. **Fire the signal in `CreateOrderSerializer.save`**:
 
   - ```py
     from .signals import order_created
     order_created.send_robust(sender=self.__class__, order=order)
     ```

   - `send_robust` ensures other receivers are still notified even if one raises some exception.
   - Another is `send` in which if a receiver raises exception, subsequent receivers aren't notified.

3. **Receive the signal in core app**:

   - Create `signals/handlers.py` in `core`.
   - Import `order_created` from `store.signals`.
   - Define handler:

     ```py
     from django.dispatch import receiver
     @receiver(order_created)
     def on_order_created(sender, **kwargs):
         print(kwargs['order'])
     ```

   - In `core/apps.py` → `ready()` → `from .signals import handlers`.

**Outcome:**

- When an order is created in **store**, `order_created` is fired.
- Any app listening to it receives the `order` object and can react.
