## Designing the API

Clients should be able to:

- Create a cart
- Get a cart with all items
- Delete a cart
- Add items to a cart
- Update quantity of an item
- Remove an item from a cart

<br>

Cart Endpoints:

| Action      | Method | URL           | Request Body | Response                               |
| ----------- | ------ | ------------- | ------------ | -------------------------------------- |
| Create Cart | POST   | `/carts`      | {}           | Created cart object (with unique `id`) |
| Get Cart    | GET    | `/carts/{id}` | {}           | Cart object                            |
| Delete Cart | DELETE | `/carts/{id}` | {}           | {}                                     |

Notes:

- No user/customer ID sent since we want the cart to be available even if user has not logged-in.
- Cart `id` would be saved on client for subsequent requests.

CartItem Endpoints:

| Action          | Method | URL                                | Request Body                 | Response            |
| --------------- | ------ | ---------------------------------- | ---------------------------- | ------------------- |
| Add Item        | POST   | `/carts/{cart_id}/items`           | `{"product_id", "quantity"}` | Created item object |
| Update Item Qty | PATCH  | `/carts/{cart_id}/items/{item_id}` | `{"quantity"}`               | Updated item object |
| Delete Item     | DELETE | `/carts/{cart_id}/items/{item_id}` | {}                           | {}                  |

<br>

Implementation:

- 4 endpoints in total: 2 for carts, 2 for cart items
- Use `CartViewSet` for cart endpoints
- Use `CartItemViewSet` for item endpoints

## Revisiting the Data Model

### [`Cart`] Problem with Default `id` Field

- Django uses `IntegerField` as the default primary key.
- Leads to predictable URLs like `/carts/1`, `/carts/2`, etc.
- Vulnerable to enumeration attacks.

**Solution:** Use GUID (Globally Unique IDentifier) for Cart ID:

- Change `id` to `models.UUIDField(primary_key=True, default=uuid.uuid4)`
  (UUID: Universally Unique IDentifiers)

Note: Directly changing and running migration results in `django.db.utils.ProgrammingError: cannot cast type bigint to uuid` for Postgres. Solution: Read TLDR in the end: https://g.co/gemini/share/dc368526147a

Storage Implications:

- Integer (default) = 8 bytes
- UUID = 32 bytes
- CartItem model also stores `cart_id` → 24 bytes extra per row
- 1 million records = ~23 MB extra → negligible
- Cart table is temporary; old carts can be cleaned periodically

Performance Considerations:

- UUID lookups are slightly slower than integer
- Modern hardware and optimized DB engines can handle this easily
- "Premature optimization is the root of all evils." - Donald Knuth

**Alternative Solution:** Store UUID in separate field, keep `id` as integer:

- URLs would be like `/carts/uuid`; CartItem would store `id` only
- Adds bit of code complexity

### [`CartItem`] Enforce Unique Product per Cart

Prevent duplicate cart items for same product:

```py
class Meta:
    unique_together = [["cart", "product"]]
```

## Creating a Cart

### [Revision] Steps in building an API

1. Serializer
2. View
3. Route

<br>

In serializer's `Meta` class, we need to add following so that `id` is auto-generated instead of required for `POST`/`PUT`/`PATCH`:

```py
        read_only_fields = ["id"]
```

[Specifying read only fields](https://www.django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields)

In view:

```py
# At first, you might do:
class CartSerializer(serializers.ModelSerializer):
    ...
# But, doing this would allow all the operations (CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin, ListModelMixin, GenericViewSet, which provides `create()`, `retrieve()`, `update()`, `partial_update()`, `destroy()` and `list()` actions) to the `/carts` endpoint. (See `ModelSerializer` definition.)
# So, e.g. `ListModelMixin` would allow `GET \carts`, which if you still don't realize, would reveal the cart IDs, so anyone would be able to manipulate any cart.

# So, what we instead want is just `CreateModelMixin` (with `GenericViewSet` which includes methods like `get_queryset`):
class CartViewSet(CreateModelMixin, GenericViewSet):
    ...
```

## Getting a Cart

See the video and code (`CartSerializer`, `CartItemSerializer`, `SimpleProductSerializer`, `CartViewSet`).

##

### `Meta.read_only_fields` attr vs `read_only` param

If a new field is defined in the serializer, or if an actual DB field is re-defined in the serializer, then only the `read_only` param works — `Meta.read_only_fields` does not.

> Can't see this mentioned [here (django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields)](https://www.django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields) though.

## Deleting a Cart

Just add `DestroyModelMixin` to `CartViewSet`.

## Getting Cart Items

See the video and code (`CartItemViewSet`, `cart_router`).

## Adding a Cart Item

> Different from Mosh:
>
> Removed `product = SimpleProductSerializer()` from `CartItemSerializer` because by default `product` field which is `id` looks like a better behavior to me.  
> Our client can get the actual `Product` objects using the `id`s (`GET /store/products/<id>`) if they want.
>
> Doing this change, only one serializer class was required instead of two, for implementing adding cart item functionality.

See the code (`CartItemViewSet.get_serializer_class`, `CartItemViewSet.get_serializer_context`, `CartItemSerializer.save`) and video for complete understanding.

Note: The way we've done `CartItemViewSet.get_serializer_class` and `CartItemSerializer.save` is the standard and recommended way in DRF.

## Updating a Cart Item

Added:

- `UpdateCartItemSerializer` with `fields = ["quantity"]`

- `if self.request.method == "PATCH": return UpdateCartItemSerializer` in `CartItemViewSet.get_serializer_class`

- `http_method_names = ["get", "post", "patch", "delete"]` in `CartItemViewSet`

## Deleting a Cart Item

We already have this functionality since our `CartItemViewSet` is a `ModelViewSet`.
