## Designing the API

> Discussed **shopping cart API endpoints** (cart + cart items) with `POST/GET/DELETE` for carts and `POST/PATCH/DELETE` for cart items, outlining request/response structure before implementation.

Clients should be able to:

- Create a cart
- Get a cart with all items
- Delete a cart
- Add items to a cart
- Update quantity of an item
- Remove an item from a cart

<br>

Cart Endpoints:

| Action      | Method | URL           | Request Body | Response                               |
| ----------- | ------ | ------------- | ------------ | -------------------------------------- |
| Create Cart | POST   | `/carts`      | {}           | Created cart object (with unique `id`) |
| Get Cart    | GET    | `/carts/{id}` | {}           | Cart object                            |
| Delete Cart | DELETE | `/carts/{id}` | {}           | {}                                     |

Notes:

- No user/customer ID sent since we want the cart to be available even if user has not logged-in.
- Cart `id` would be saved on client for subsequent requests.

CartItem Endpoints:

| Action          | Method | URL                                | Request Body                 | Response            |
| --------------- | ------ | ---------------------------------- | ---------------------------- | ------------------- |
| Add Item        | POST   | `/carts/{cart_id}/items`           | `{"product_id", "quantity"}` | Created item object |
| Update Item Qty | PATCH  | `/carts/{cart_id}/items/{item_id}` | `{"quantity"}`               | Updated item object |
| Delete Item     | DELETE | `/carts/{cart_id}/items/{item_id}` | {}                           | {}                  |

<br>

Implementation:

- 4 endpoints in total: 2 for carts, 2 for cart items
- Use `CartViewSet` for cart endpoints
- Use `CartItemViewSet` for item endpoints

## Revisiting the Data Model

> Switched Cart primary key to a UUID (`uuid4` as the default), discussed size/performance tradeoffs, enforced a `unique_together` constraint on (cart, product) to prevent duplicates, and ran migrations.

### [`Cart`] Problem with Default `id` Field

- Django uses `IntegerField` as the default primary key.
- Leads to predictable URLs like `/carts/1`, `/carts/2`, etc.
- Vulnerable to enumeration attacks.

> So we can add auntheciation by linking each cart to their created user only, right?  
> No, as we're allowing anonymous carts. (Cart ids would be saved by client on user's device local storage.)

**Solution:** Use GUID (Globally Unique IDentifier) for Cart ID:

- Change `id` to `models.UUIDField(primary_key=True, default=uuid.uuid4)`
  (UUID: Universally Unique IDentifiers)

Note: Directly changing and running migration results in `django.db.utils.ProgrammingError: cannot cast type bigint to uuid` for Postgres.  
Solution: Read TLDR in the end: [Gemini](https://g.co/gemini/share/dc368526147a)

Storage Implications:

- Integer (default) = 8 bytes
- UUID = 32 bytes
- CartItem model also stores `cart_id` → 24 bytes extra per row
- 1 million records = ~23 MB extra → negligible
- Cart table is temporary; old carts can be cleaned periodically

Performance Considerations:

- UUID lookups are slightly slower than integer
- Modern hardware and optimized DB engines can handle this easily
- "Premature optimization is the root of all evils." - Donald Knuth

**Alternative Solution:** Store UUID in **separate field**, keep `id` as integer:

- URLs would be like `/carts/uuid`; CartItem would store `id` only
- Adds bit of code complexity

### [`CartItem`] Enforce Unique Product per Cart

Prevent duplicate cart items for same product:

```py
class Meta:
    unique_together = [["cart", "product"]]
```

> Note that we'd explicitly prevent (by overriding `save` in serializer) adding an item which is already there in the cart, we'd just increasing its quantity. Above is DB level safety, if because of a bug, code re-adds an already existing item, DB would throw error.

## Creating a Cart

> Built `CartSerializer` (with `id` as read-only), implemented a custom `CartViewSet` (only `create` op via `CreateModelMixin` + `GenericViewSet`), registered the `carts/` route, and verified cart creation works via POST.

**[Revision] Steps in building an API:** Serializer → View → Route

In serializer's `Meta` class, set `id` to read-only so that it is auto-generated instead of required for `POST`:

```py
        read_only_fields = ["id"]
```

But id fields are read-only by default by DRF, right?

> "Model fields which have `editable=False` set, and `AutoField` fields will be set to read-only by default"

[Specifying read only fields](https://www.django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields)

In view, at first, you might do:

```py
class CartSerializer(serializers.ModelSerializer):
    ...
```

But, doing this would allow all the operations to the `/carts` endpoint. (See `ModelSerializer` definition.)  
So, e.g. `ListModelMixin` would allow `GET /carts`, which if you still don't realize, would reveal **ALL** the cart IDs, so anyone would be able to manipulate any cart.

So, what we instead want for now is just `CreateModelMixin` (with `GenericViewSet` which includes methods like `get_queryset`):

```py
class CartViewSet(CreateModelMixin, GenericViewSet):
    ...
```

Now, `GET /carts` = `HTTP 405 Method Not Allowed`

## Getting a Cart

> Created `CartItemSerializer` + `SimpleProductSerializer`, added items and total price fields to `CartSerializer`, used `SerializerMethodField` for totals, optimized queries with `prefetch_related('cartitem_set__product')`, and returned cart with items, product details, and computed totals.

See the video and code (`CartSerializer`, `CartItemSerializer`, `SimpleProductSerializer`, `CartViewSet`).

##

### `read_only_fields` attr vs `read_only` param

If a new field is **defined** in the serializer, or if an actual DB field is re-defined in the serializer, then only the `read_only` param works — `Meta.read_only_fields` does not.

> Can't see this mentioned [here (django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields)](https://www.django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields) though.

## Deleting a Cart

> Implemented by adding `DestroyModelMixin` to `CartViewSet`, and verified successful cart deletion via DELETE request.

Just add `DestroyModelMixin` to `CartViewSet`.

## Getting Cart Items

> Built `CartItemViewSet` with nested routing to manage cart items (CRUD) filtered by cart ID, and optimized queries using `select_related` for products.

See the video and code (`CartItemViewSet`, `cart_router`).

## Adding a Cart Item

> Adding cart items requires overriding the serializer’s `save` method to either update quantity if the product already exists in the cart or create a new cart item, while also validating quantity (`MinValueValidator(1)`).

### Different from Mosh

- Removed `product = SimpleProductSerializer()` from `CartItemSerializer` because by default `product` field which is `id` looks ok to me.

  Our client can get the actual `Product` objects using the `id`s (`GET /store/products/<id>`).

- Doing this change, we were no longer required to add a dedicated serializer class (`AddCartItemSerializer`).

- Why were two serializer classes required though? Because of the simple reason:

  The same serializer that returned cart items also forced us to **send a full product object when adding to the cart**, which didn’t make sense—we only needed `product_id` and `quantity`. Making `product` read-only removed it but then adding `product_id` inside the same serializer was **ugly and redundant** (acc. to Mosh), since on updates we don’t want to resend product information. To solve this cleanly, one serializer (`CartItemSerializer`) was kept for reading cart items, and another (`AddCartItemSerializer`) was created for adding items with just the necessary fields.

See the code (`CartItemViewSet.get_serializer_context`, `CartItemSerializer.save`) and video for complete understanding.

Note: The way we're doing `CartItemSerializer.save` is the standard and recommended way in DRF.

## Updating a Cart Item

> Handled with a custom `UpdateCartItemSerializer` (only `quantity` field), using `PATCH` instead of `PUT`, and restricting allowed methods to `GET, POST, PATCH, DELETE`.

Added:

- New `UpdateCartItemSerializer` with:
  
  `fields = ["quantity"]`

- In `CartItemViewSet.get_serializer_class`:

  `if self.request.method == "PATCH": return UpdateCartItemSerializer`

- In `CartItemViewSet`:

  `http_method_names = ["get", "post", "patch", "delete"]`

## Deleting a Cart Item

> Deleting a cart item requires no extra code since `ModelViewSet` already supports `DELETE`; just ensure http method names are lowercase and test the deletion.

We already have this functionality since our `CartItemViewSet` is a `ModelViewSet`.
