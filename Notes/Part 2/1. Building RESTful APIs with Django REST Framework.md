**[Important](/Notes/Part%201/1.%20Django%20Fundamentals.md#important):**

> **We don't use templates in Django that often now. Django is primarily used to build APIs. (DRF)**

<br>

**DRF: [django-rest-framework.org](https://www.django-rest-framework.org)**

**Quickstart Guide: [django-rest-framework.org/tutorial/quickstart](https://www.django-rest-framework.org/tutorial/quickstart)**

## What are RESTful APIs

- REST = Representational State Transfer
- Concept introduced in a PhD thesis (2000)
- REST defines rules for communication between client and server
- APIs that follow these rules are called RESTful APIs

### Why use REST?

RESTful APIs help build systems that are:

- Fast
- Scalable
- Reliable
- Easy to understand
- Easy to maintain/change

### Core REST Concepts:

1. Resources
2. Resource Representations
3. HTTP Methods

## Resources

- A **resource** in a REST API is like an object in the application.

  - Examples: `Product`, `Collection`, `ShoppingCart`, `Review`, etc.

- Resources are accessed via **URLs** (Uniform Resource Locator).

  - Example:

    - All products → `moshby.com/products`
    - A specific product → `moshby.com/products/1`
    - Reviews for product 1 → `moshby.com/products/1/reviews`
    - A specific review → `moshby.com/products/1/reviews/2`

### Best Practice:

- Avoid deep nesting in URLs — **no more than 2 levels** to keep them clean and manageable.
- Consistent URL patterns help make APIs **familiar and predictable**.

## Resource Representations

- Clients identify a resource via its **URL**.
- The **server returns the resource in a specific format**, such as:

  - **HTML**
  - **XML** (older format)
  - **JSON** (modern standard)

> These are just **representations** — **not** the actual internal object.

### On the Server:

- A resource is an **object or class instance** (e.g., Python object).

### JSON (JavaScript Object Notation):

- Common format for sending/receiving data between client and server.

- Structure:

  ```json
  {
    "name": "Samyak",
    "age": 24,
    "isOnline": true,
    "employer": {
      "name": "RapidKen"
    },
    "interests": []
  }
  ```

- Rules:

  - Keys must be **strings** (in double quotes)
  - Values can be: string, number, boolean, object, or array

## HTTP Methods

HTTP methods define **what action** the client wants to perform on a resource:

| Method   | Purpose                             | Example URL                  | Body Required? |
| -------- | ----------------------------------- | ---------------------------- | -------------- |
| `GET`    | Read/fetch a resource or collection | `/products` or `/products/1` | No             |
| `POST`   | Create a new resource               | `/products`                  | Yes (JSON)     |
| `PUT`    | Replace **entire** resource         | `/products/1`                | Yes (JSON)     |
| `PATCH`  | Update **part** of a resource       | `/products/1`                | Yes (JSON)     |
| `DELETE` | Delete a resource                   | `/products/1`                | No             |

### Notes:

- When sending data (for `POST`, `PUT`, or `PATCH`), it's included in the **request body as JSON**.
- The **resource ID** is typically included in the **URL** (for PUT, PATCH, DELETE).

## Installing Django REST Framework

1. `pipenv install djangorestframework`

2. Add `"rest_framework"` to `INSTALLED_APPS`

## Creating API Views

```py
from django.http import HttpRequest, HttpResponse
from rest_framework.decorators import api_view
from rest_framework.request import Request
from rest_framework.response import Response

# Without DRF:
def product_list(request: HttpRequest):
    return HttpResponse("OK")

# Using DRF, we get browseable API:
@api_view()
def product_list(request: Request):
    return Response("OK")
```

## Creating Serializers

Serializer: Converts a model instance to a dictionary.

```py
class <ModelName>Serializer(serializers.Serializer):
    field1 = ...
    field2 = ...
    ...

# e.g.
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    ...
```

Check the code in `store.serializers.ProductSerializer()`.

Serializer fields: [django-rest-framework.org/api-guide/fields](https://www.django-rest-framework.org/api-guide/fields)

## Serializing Objects

Basic:

```py
@api_view()
def product_detail(request, id: int):
    product = Product.objects.get(pk=id)  # get the object (or queryset)
    serializer = ProductSerializer(product)  # convert object (or queryset) to dict (or list of dicts), returns a serializer obj
    return Response(serializer.data)  # `.data` gives us the dict (or list of dicts)
```

Check the code in `store.views.product_detail()`, `store.views.product_list()`.

## Creating Custom Serializer Fields

Just like we can show [custom fields in admin](/Notes/Part%201/5.%20The%20Admin%20Site.md#adding-computed-columns), we can do in the API as well, in the `<ModelName>Serializer` class:

```py
    price_plus_tax = serializers.SerializerMethodField(method_name="get_price_plus_tax")

    def get_price_plus_tax(self, product: Product):
        return round(product.unit_price * Decimal(1.1), 2)
```

We can also change the name with which existing DB fields appear in the API:

```py
new_name = Serializer.<Field>(source="field_name_in_db")
```

Why would we want to do this?  
One use-case: internal name is changed, but if we change the external field usage name, all existing client code would break, we can avoid that using this.

## Serializing Relationships

We've many ways to serialize (and show) related fields on our API:

- **Primary Key** (pk/id of related field)

  E.g., to see collection id of each product, in `ProductSerializer`:

  ```py
      collection = serializers.PrimaryKeyRelatedField(queryset=Collection.objects.all())
  ```

- **String** (another column of related field's table)

  To see collection title:

  ```py
      collection = serializers.StringRelatedField()
      # + `select_related("collection")` in view, else N+1 query problem
  ```

- **Nested Object** (the object itself of related field table)

  To see whole collection object:

  ```py
      # Define `CollectionSerializer` and use:
      collection = CollectionSerializer()
  ```

- **Hyperlink** (link to related field's API endpoint)

  To see link to collection endpoint:

  ```py
      collection = serializers.HyperlinkedRelatedField(
          view_name="collection-detail", queryset=Collection.objects.all()
      )
  ```

  Three things required to make this work:

  1. "AssertionError at /store/products/: `HyperlinkedRelatedField` requires the request in the serializer context. Add `context={'request': request}` when instantiating the serializer."
  2. `name="collection-detail"` in `urls.urlpatterns.path()`
  3. `"collections/<int:pk>/"` in `urls.urlpatterns.path()` instead of `"collections/<int:id>/"`, this is DRF's default convention.

## Model Serializers

Creating serializers [this way](/Notes/Part%202/1.%20Building%20RESTful%20APIs%20with%20Django%20REST%20Framework.md#creating-serializers) obviously breaks Django's primary principle of DRY.

Correct way is using `ModelSerializer`, and use the explicit method only when specifically required, e.g., for [Creating Custom Serializer Fields](/Notes/Part%202/1.%20Building%20RESTful%20APIs%20with%20Django%20REST%20Framework.md#creating-custom-serializer-fields).

```py
class ProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Product
        fields = ["id", "title", "unit_price", "price_plus_tax", "collection"]

    price_plus_tax = serializers.SerializerMethodField(method_name="get_price_plus_tax")

    def get_price_plus_tax(self, product: Product):
        return round(product.unit_price * Decimal(1.1), 2)

    collection = serializers.HyperlinkedRelatedField(
        view_name="collection-detail", queryset=Collection.objects.all()
    )
```

## Deserializing Objects

Deserialize: Get model object from a `dict` received in `request.data`.

Usage: E.g., when using `POST`, we receive the data from the client.

Also, we need to add the HTTP methods allowed on a particular endpoint. `GET` is supported by default.

> And this brings up a form to `POST` on the endpoint, that's the beauty of DRF's browsable API.

Check the code in `store.views.product_list()`.

## Data Validation

Check the code in `store.views.product_list()`.

- `request.data` == `serializer.initial_data`: Actual `dict` came with `POST`.

- `serializer.is_valid(raise_exception=True)`: Runs validation. DRF auto-generates rules based on `models.<Field>`.

- `serializer.validated_data`: A validated `dict`. Related fields are actual objects now.

### Customizing Validations

Suppose we want `password` field to match `confirm_password` field. If not matched, then the data is invalid.  
We can override `validate` method in `<ModelName>Serializer` class:

```py
def validate(self, data):
    if data["password"] != data["confirm_password"]:
        return serializers.ValidationError("Passwords do not match.")
    return data
```

## Saving Objects

`PUT` vs `PATCH`:

- https://g.co/gemini/share/14197b18ee01
- https://www.perplexity.ai/search/put-vs-patch-SbtTvJ71RIOVmx4V5Ak_8A

### Saving

```py
        # `save()` would call `create()`:
        serializer = ProductSerializer(data=request.data)
        ...
        serializer.save()
        # REST convention to return the created data, and status 201:
        return Response(serializer.data, status=status.HTTP_201_CREATED)

        # `save()` would call `update()`:
        serializer = ProductSerializer(product, data=request.data)
        ...
        serializer.save()
        # REST convention to return the updated data:
        return Response(serializer.data)
```

### Overriding `create()` / `update()`

If we want to change the default `create()` / `update()` to include some other things, we can:

```py
def create(self, validated_data):
    product = Product(**validated_data)
    product.other = 1
    product.save()
    return product

def update(self, instance, validated_data):
    instance.unit_price = validated_data.get("unit_price")
    instance.save()
    return instance
```

## Deleting Objects

To delete a product:

```py
        # `ProtectedError`: protected foreign keys, so:
        if product.orderitem_set.count() > 0:
            return Response(status=status.HTTP_405_METHOD_NOT_ALLOWED)

        product.delete()
        # Again, this is REST convention:
        return Response(status=status.HTTP_204_NO_CONTENT)
```

### Which status code to return?

Refer:

- [wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
- [httpstatuses.io](https://httpstatuses.io)

## Exercise: Building the Collections API

Same as above implementation, only difference is using following in views:

```py
Collection.objects.annotate(product_count=Count("product"))
```

which adds a `product_count` field to the API.

See the code, and/or watch the video again.
