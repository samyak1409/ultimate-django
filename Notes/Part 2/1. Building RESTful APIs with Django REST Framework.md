**[Important](/Notes/Part%201/1.%20Django%20Fundamentals.md#important):**

> **We don't use templates in Django that often now. Django is primarily used to build APIs. (DRF)**

**DRF: [django-rest-framework.org](https://www.django-rest-framework.org)**

**Quickstart Guide: [django-rest-framework.org/tutorial/quickstart](https://www.django-rest-framework.org/tutorial/quickstart)**

## What are RESTful APIs

- REST = Representational State Transfer
- Concept introduced in a PhD thesis (2000)
- REST defines rules for communication between client and server
- APIs that follow these rules are called RESTful APIs

### Why use REST?

RESTful APIs help build systems that are:

- Fast
- Scalable
- Reliable
- Easy to understand
- Easy to maintain/change

### Core REST Concepts:

1. Resources
2. Resource Representations
3. HTTP Methods

## Resources

- A **resource** in a REST API is like an object in the application.

  - Examples: `Product`, `Collection`, `ShoppingCart`, `Review`, etc.

- Resources are accessed via **URLs** (Uniform Resource Locator).

  - Example:

    - All products → `moshby.com/products`
    - A specific product → `moshby.com/products/1`
    - Reviews for product 1 → `moshby.com/products/1/reviews`
    - A specific review → `moshby.com/products/1/reviews/2`

### Best Practice:

- Avoid deep nesting in URLs — **no more than 2 levels** to keep them clean and manageable.
- Consistent URL patterns help make APIs **familiar and predictable**.

## Resource Representations

- Clients identify a resource via its **URL**.
- The **server returns the resource in a specific format**, such as:

  - **HTML**
  - **XML** (older format)
  - **JSON** (modern standard)

> These are just **representations** — **not** the actual internal object.

### On the Server:

- A resource is an **object or class instance** (e.g., Python object).

### JSON (JavaScript Object Notation):

- Common format for sending/receiving data between client and server.

- Structure:

  ```json
  {
    "name": "Samyak",
    "age": 24,
    "isOnline": true,
    "employer": {
      "name": "RapidKen"
    },
    "interests": []
  }
  ```

  - Keys must be **strings** (in double quotes)
  - Values can be: string, number, boolean, object, or array

## HTTP Methods

HTTP methods define **what action** the client wants to perform on a resource:

| Method   | Purpose                             | Example URL                  | Body Required? |
| -------- | ----------------------------------- | ---------------------------- | -------------- |
| `GET`    | Read/fetch a resource or collection | `/products` or `/products/1` | No             |
| `POST`   | Create a new resource               | `/products`                  | Yes (JSON)     |
| `PUT`    | Replace **entire** resource         | `/products/1`                | Yes (JSON)     |
| `PATCH`  | Update **part** of a resource       | `/products/1`                | Yes (JSON)     |
| `DELETE` | Delete a resource                   | `/products/1`                | No             |

### Notes:

- When sending data (for `POST`, `PUT`, or `PATCH`), it's included in the **request body as JSON**.
- The **resource ID** is typically included in the **URL** (for PUT, PATCH, DELETE).

## Installing Django REST Framework

1. `pipenv install djangorestframework`

2. Add `"rest_framework"` to `INSTALLED_APPS`

## Creating API Views

> Creating API endpoints in DRF: built `store/products` and `store/products/<id>` views with `@api_view`, added URL patterns, checked Browseable API, and enforced integer ID validation.

```py
from django.http import HttpRequest, HttpResponse
from rest_framework.decorators import api_view
from rest_framework.request import Request
from rest_framework.response import Response

# Without DRF:
def product_list(request: HttpRequest):
    return HttpResponse("OK")

# Using DRF, we get browseable API:
@api_view()
def product_list(request: Request):
    return Response("OK")
```

## Creating Serializers

> Introduced serializers in DRF to convert model instances into JSON-ready Python dictionaries, and created a `ProductSerializer` defining selected fields (id, title, unit_price).

Serializer: Converts a model instance to a dictionary.

```py
class <ModelName>Serializer(serializers.Serializer):
    field1 = ...
    field2 = ...
    ...

# e.g.
class ProductSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    title = serializers.CharField(max_length=255)
    ...
```

Check the code in `store.serializers.ProductSerializer()`.

Serializer fields: [django-rest-framework.org/api-guide/fields](https://www.django-rest-framework.org/api-guide/fields)

## Serializing Objects

> Used `ProductSerializer` to return single/all products as JSON, handled non-existing products with `get_object_or_404`, and configured DRF to render decimals properly (`"COERCE_DECIMAL_TO_STRING": False`).

Basic:

```py
@api_view()
def product_detail(request, id: int):
    product = Product.objects.get(pk=id)  # get the object (or queryset)
    serializer = ProductSerializer(product)  # convert object (or queryset) to dict (or list of dicts), returns a serializer obj
    return Response(serializer.data)  # `.data` gives us the dict (or list of dicts)
```

Check the code in `store.views.product_list()`, `store.views.product_detail()`.

## Creating Custom Serializer Fields

> Explained how serializers let us decouple internal models from API responses by renaming fields and adding computed fields (e.g., `price_with_tax`) using `SerializerMethodField` and `source`.

Just like we can show [custom fields in admin](/Notes/Part%201/5.%20The%20Admin%20Site.md#adding-computed-columns), we can do in the API as well, in the `<ModelName>Serializer` class:

```py
    price_plus_tax = serializers.SerializerMethodField(method_name="get_price_plus_tax")

    def get_price_plus_tax(self, product: Product):
        return round(product.unit_price * Decimal(1.1), 2)
```

We can also change the name with which existing DB fields appear in the API:

```py
new_name = Serializer.<Field>(source="field_name_in_db")
```

Why would we want to do this?  
One use-case: internal name is changed, but if we change the external field usage name, all existing client code would break, we can avoid that using this. (Cool!)

## Serializing Relationships

> Covered four ways to serialize relationships in DRF — primary key, string, nested object, and hyperlink — plus fixing performance with `select_related` and passing `request` in serializer context.

We've many ways to serialize (and show) related fields on our API:

- **Primary Key** (pk/id of related field)

  E.g., to see collection id of each product, in `ProductSerializer`:

  ```py
      collection = serializers.PrimaryKeyRelatedField(queryset=Collection.objects.all())
  ```

- **String** (string representation (`__str__()`) of related object)

  To see collection's str repr (currently set as collection title):

  ```py
      collection = serializers.StringRelatedField()
      # + `select_related("collection")` in view, else N+1 query problem
  ```

- **Nested Object** (the object itself of related field table)

  To see whole collection object:

  ```py
      # Define `CollectionSerializer` and use:
      collection = CollectionSerializer()
  ```

- **Hyperlink** (link to related field's API endpoint)

  To see link to collection endpoint:

  ```py
      collection = serializers.HyperlinkedRelatedField(
          view_name="collection-detail", queryset=Collection.objects.all()
      )
  ```

  Three things required to make this work:

  1. "AssertionError at /store/products/: `HyperlinkedRelatedField` requires the request in the serializer context. Add `context={'request': request}` when instantiating the serializer."
  2. `name="collection-detail"` in `urls.urlpatterns.path()`
  3. `"collections/<int:pk>/"` in `urls.urlpatterns.path()` instead of `"collections/<int:id>/"`, this is DRF's default convention.

## Model Serializers

> Introduced **ModelSerializers** in DRF to avoid duplication, auto-generate fields from models, override only when needed, add custom fields like `price_with_tax`, and avoid using `__all__` for security.

Creating serializers [this way](/Notes/Part%202/1.%20Building%20RESTful%20APIs%20with%20Django%20REST%20Framework.md#creating-serializers) obviously breaks Django's primary principle of DRY.

Correct way is using `ModelSerializer`, and use the explicit method only when specifically required, e.g., for [creating custom serializer fields](/Notes/Part%202/1.%20Building%20RESTful%20APIs%20with%20Django%20REST%20Framework.md#creating-custom-serializer-fields). (Or when our API doesn't have DB models.)

```py
class ProductSerializer(serializers.ModelSerializer):

    class Meta:
        model = Product
        fields = ["id", "title", "unit_price", "price_plus_tax", "collection"]

    price_plus_tax = serializers.SerializerMethodField(method_name="get_price_plus_tax")

    def get_price_plus_tax(self, product: Product):
        return round(product.unit_price * Decimal(1.1), 2)

    collection = serializers.HyperlinkedRelatedField(
        view_name="collection-detail", queryset=Collection.objects.all()
    )
```

## Deserializing Objects

> Explained **deserialization** in DRF by handling POST requests, passing `request.data` into the serializer, and preparing for validation before saving objects to the database.

Deserialize: Get model object from a `dict` received in `request.data`.

Usage: E.g., when using `POST`, we receive the data from the client.

Also, we need to add the HTTP methods allowed on a particular endpoint. `GET` is supported by default.

> And this brings up a form to `POST` on the endpoint, that's the beauty of DRF's browsable API.

Check the code in `store.views.product_list()`.

## Data Validation

> Covered **data validation** in DRF: using `is_valid()` or `raise_exception=True`, accessing `validated_data`, handling field/object-level validation, and returning proper 400 responses with errors.

Check the code in `store.views.product_list()`.

- `request.data` == `serializer.initial_data`: Actual `dict` came with `POST`.

- `serializer.is_valid(raise_exception=True)`: Runs validation. DRF auto-generates rules based on `models.<Field>`.

- `serializer.validated_data`: A validated `dict`. Related fields are actual objects now.

### Customizing Validations

Suppose we want `password` field to match `confirm_password` field. If not matched, then the data is invalid.  
We can override `validate` method in the serializer:

```py
def validate(self, data):
    if data["password"] != data["confirm_password"]:
        raise serializers.ValidationError("Passwords do not match.")
    return data
```

[django-rest-framework.org/api-guide/serializers/#validation](https://www.django-rest-framework.org/api-guide/serializers/#validation)

[django-rest-framework.org/api-guide/validators/#writing-custom-validators](https://www.django-rest-framework.org/api-guide/validators/#writing-custom-validators)

## Saving Objects

> Explained how to **save and update data** in DRF using `serializer.save()`, customizing `create`/`update` if needed, handling PUT/PATCH requests, and following REST conventions (returning created/updated objects with proper status codes).

`PUT` vs `PATCH`:

- [Gemini](https://g.co/gemini/share/14197b18ee01)
- [Perplexity](https://www.perplexity.ai/search/put-vs-patch-SbtTvJ71RIOVmx4V5Ak_8A)

### Saving

```py
        # `save()` would call `create()`:
        serializer = ProductSerializer(data=request.data)
        ...
        serializer.save()
        # REST convention to return the created data, and status 201:
        return Response(serializer.data, status=status.HTTP_201_CREATED)

        # `save()` would call `update()`:
        serializer = ProductSerializer(product, data=request.data)
        ...
        serializer.save()
        # REST convention to return the updated data:
        return Response(serializer.data)
```

### Overriding `create()` / `update()`

If we want to change the default `create()` / `update()` to include some other things, we can. In serializer:

```py
def create(self, validated_data):
    product = Product(**validated_data)
    product.something = 1
    product.save()
    return product

def update(self, instance, validated_data):
    instance.unit_price = validated_data.get("unit_price")
    instance.save()
    return instance
```

## Deleting Objects

> Covered **deleting products** in DRF: implementing DELETE with 204 No Content, handling foreign key constraints gracefully (e.g., return 405 with error message if product is linked to orders).

To delete a product:

```py
        # `ProtectedError`: protected foreign keys, so:
        if product.orderitem_set.exists():
            return Response(status=status.HTTP_409_CONFLICT)

        product.delete()
        # Again, this is REST convention:
        return Response(status=status.HTTP_204_NO_CONTENT)
```

See `store.views.product_detail()` for complete code.

### Which status code to return?

Refer:

- [wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
- [httpstatuses.io](https://httpstatuses.io)

## Exercise: Building the Collections API

> Implemented **collections endpoint**: list/create collections with annotated product counts, retrieve/update/delete individual collections (with delete blocked if products exist), and updated related names/serializer fields accordingly.

Similar as above implementation, only differences to add a read-only `product_count` field to the API:

1. In serializers:

   ```py
       # Since `product_count` is not a DB field:
       product_count = serializers.IntegerField(read_only=True)
       # `read_only=True`: Restrict adding/changing while `POST`/`PUT`/`PATCH`.
   ```

   [django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields](https://www.django-rest-framework.org/api-guide/serializers/#specifying-read-only-fields)

2. In views:

   ```py
       Collection.objects.annotate(product_count=Count("product"))
   ```

See the code, and/or watch the video again.
