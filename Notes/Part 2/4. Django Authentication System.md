## Django Authentication System

### Default Auth App

- Every Django project includes `django.contrib.auth`.

- Provides:

  - User identification
  - Login/logout
  - Password change
  - Permissions and groups

### Models and Tables

- Auth app includes:

  - `User`
  - `Group`
  - `Permission`

- Corresponding tables are automatically created in the DB.

#### `User` Table Fields:

- `id`: User ID
- `password`: Stored in encrypted format
- `last_login`
- `is_superuser`: User has all permissions
- `username`, `first_name`, `last_name`, `email`
- `is_staff`: Can access admin panel
- `is_active`
- `date_joined`

<br>

### What is Middleware?

- A function that processes a request before it reaches the view.

- Each middleware takes an incoming request, adds something to it, and then passes it to the next middleware.

- Can:

  - Modify request
  - Return a response directly (short-circuiting the rest)

### Authentication Middleware

- Located in the `MIDDLEWARE` setting.

- Sets the `request.user` attribute.

  - Could be an instance of `AnonymousUser` or a logged-in `User`.

<br>

### Summary

- Django’s auth system is powerful and customizable.
- Includes user management and permissions.
- Middleware plays a key role in attaching user info to each request.

## Customizing the User Model

### Two approaches to store additional user data:

#### 1. Inheritance

- Create a custom model (e.g. `AppUser`) that **inherits from Django’s built-in `AbstractUser` model**.

- This extends the **original user table** directly.

- Use this only when adding **auth-related fields** (e.g. custom login fields, flags, or permission-related attributes).

#### 2. Composition (Preferred)

- Create a separate **Profile model** with a **OneToOneField** to the `User` model.

- Stores additional data like birth date, address, etc.

- Each app can define its own concept of a profile, e.g.:

  - `Customer` in sales app
  - `Employee` in HR app
  - `Student` in training app

- Enables modular and scalable profile handling.

### When to use which?

- **Use inheritance** → Only when modifying behavior of authentication.
- **Use composition** → For storing all non-auth related data.

### Additional Notes

- First approach **modifies the user table**, second approach creates a **separate table with a foreign key**.
- You **cannot switch to inheritance** mid-project; it's tricky and discouraged.
- So most of the time, use the **second (composition) approach**.

## Extending the User Model

### Why extend?

One requirement can be:

- Django's built-in `User` model does **not enforce unique emails**.
- To support **email-based login**, we need to apply a **unique constraint** on `email`.
- This is an **auth-related change**, so inheritance-based extension is suitable.

### Where to add the new model?

- Don't add it in `store` app (not auth-related).

- Use an app meant for **project-specific logic** (`store` is a re-usable app).

- That's `store_custom`, we created it for this project specifically.

- Rename `store_custom` app → `core`.

  - Rename app class: `StoreCustomConfig` → `CoreConfig`.
  - Update name in `apps.py` and `INSTALLED_APPS`.

### Creating custom user model

In `core/models.py`, define:

```py
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    email = models.EmailField(unique=True)
```

In `settings.py`, set:

```py
# Telling django to use this custom User model (defined in `core.models`, extends django's `AbstractUser`) for auth:
AUTH_USER_MODEL = "core.User"
```

### Swapping the user model mid-project? (NOT recommended)

If another app (e.g. `likes`) uses the old user model, don't import custom model directly (`from core.models import User`), breaks app reusability.  
Instead, use:

```py
from django.conf import settings
settings.AUTH_USER_MODEL
```

> Keeps dependent app decoupled and reusable.

And do:

```sh
python manage.py makemigrations
```

### Migration error

On doing:

```sh
python manage.py migrate
```

We'll get:

> django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency core.0001_initial on database 'default'.

Happens because admin migrations used the old model.

**Only Solution: drop and recreate database**.

```sql
DROP DATABASE <db_name>;
CREATE DATABASE <db_name>;
```

Then run:

```sh
python manage.py migrate
```

> Hence, **avoid swapping user model mid-project**. Always define custom user model at the **start** — even if it's empty (use `pass`).

### Admin panel fixes

- After recreating DB:

  - Create a superuser: `python manage.py createsuperuser`
  - `User` no longer shows under `auth`, must be registered under `core`.

#### In `core/admin.py`:

```py
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User

@admin.register(User)
class UserAdmin(BaseUserAdmin):
    ...  # see `core/admin.py`
```

> Ensure `email` is included in `add_fieldsets`, or creation fails due to unique constraint.

### Summary: How to properly extend the user model

1. Create `User` model extending `AbstractUser`.
2. Set `AUTH_USER_MODEL` in settings.
3. Never import `User` directly — use `settings.AUTH_USER_MODEL`.
4. Register admin using `BaseUserAdmin`.
5. Create `add_fieldsets` if you’ve added required fields (like email).
6. **Do all this at project start**, not in the middle.

## Creating user Profiles

### Linking User Model to Profile (e.g., `Customer`)

- In a reusable app like `store`, avoid importing a specific user model.
- Instead, use:

```py
from django.conf import settings
user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
```

> Ensures compatibility with both built-in and custom user models.

### Remove Redundant Fields

- Fields like `first_name`, `last_name`, and `email` already exist in `User`.
- Delete these from the `Customer` model.

### Update `__str__`

- Since `first_name` and `last_name` were removed, access them via the `user`:

```py
def __str__(self):
    return f"{self.user.first_name} {self.user.last_name}"
```

### Update <Model>Admin

- In `CustomerAdmin`:

  - Replace all the attributes containing `"first_name"`/`"last_name"` with `"user__first_name"`/`"user__last_name"`
  - And add `list_select_related = ["user"]` to avoid N+1 queries

### Final Outcome

- `Customer` table now links to `User` via foreign key.

- Redundant fields removed.

- First/last name data comes from related `User`.

- Admin panel supports:

  - Viewing and sorting customers by first/last name
  - Selecting users via dropdown

> Optional enhancement: Replace dropdown with autocomplete box for better UX.

### Recap

- Profile model = `Customer`
- Linked via `OneToOneField(settings.AUTH_USER_MODEL)`
- Promotes **app reusability** (not tightly coupled to a specific user model)

## Groups and Permissions

### What is a Group?

- A **group** is a collection of permissions.

- Instead of assigning permissions directly to users, we:

  - Create groups
  - Assign permissions to groups
  - Add users to those groups

### Built-in Permissions

- Django auto-generates 4 permissions for each model:

  - `add_<model>`, `change_<model>`, `delete_<model>`, `view_<model>`

- These are stored in the `auth_permission` table.

### Permission Structure

Each permission record has:

- A **unique ID**
- A **name** (human-readable)
- A **content_type_id** pointing to the model it applies to (from `django_content_type` table)
- A **codename** (used in code)

Example:

- For the `User` model in the `core` app, the permission `Can view user` will have:

  - `content_type_id`: (e.g., `19` for the `User` model)
  - `codename`: `view_user`

### Creating and Assigning Groups

1. In Django Admin:

   - Create a group (e.g., **Customer Service**)
   - Assign model-level permissions (e.g., for `Customer`, `Order`, and `OrderItem`)

2. Assign users (e.g., **TestUser**) to the group:

   - Mark them as `is_staff = True` so they can access admin
   - Add them to the appropriate group

### User Experience

- After assigning a group:
  - The user can only see/manage the models associated with that group’s permissions.

### Recap

- Groups = permission bundles
- Improves permission management
- Permissions are auto-generated per model during migrations
- Users must be marked as **staff** to access admin
- Group-based access control ensures better security and modularity

## Creating Custom Permissions

### Why Custom Permissions?

- Needed when actions don’t fit cleanly into standard CRUD operations.
- Example: **Canceling an order**

  - Not deleting or updating all fields
  - Just changing the status to `"canceled"`
  - Requires its **own permission**

### How to Create Custom Permissions

1. **Add `Meta` class** in the `Order` model:

   ```py
   class Meta:
       permissions = [
           ("cancel_order", "Can cancel order"),
       ]
   ```

   - First item: **codename** (used in code)
   - Second item: **description** (shown in admin)

2. **Run migrations**

### After Migration

- A new entry appears in the `auth_permission` table.
- You can assign this permission to any user via Django Admin.

### Next Steps

- Custom permissions can be enforced in views or APIs.
- That implementation is in **next section**.
