## Adding the Home Page

- Created `core/templates/core/index.html`

  > Why `core` subfolder is needed?
  >
  > - **Django merges all app `templates` directories into one big search path.** It doesn't keep them separate for each app.
  > - When you ask for `'index.html'`, Django uses the **first** one it finds, based on the order of your `INSTALLED_APPS`.
  > - This can cause one app's template to be used by another app by mistake (a name clash).
  > - Creating a subdirectory with the app's name (e.g., `templates/core/`) "namespaces" your templates. You then call them with `'core/index.html'`, which is a unique name that prevents any clashes.
  >
  > \- [Gemini](https://g.co/gemini/share/73e20a46eaea)

- Created `core/urls.py`.

- Used **Django’s generic `TemplateView`** to render a template instead of creating a custom view.

  - `TemplateView.as_view(template_name="core/index.html")`.

- Included core app’s URL patterns in the **main `urls.py`** (`storefront/urls.py`).

## Adding Static Assets

- **Static files in Django** = images, CSS, JS which are bundled with the app.

- In `core` app, created `static/core/` folder (namespaced).

- Saw how to do following (not doing because I'm not feeling the need to):

  1. In template:

     - At top: `{% load static %}`.
     - In `<head>`: reference stylesheet with `{% static 'core/styles.css' %}`.

  2. In `<body>`:

     - Create a container `<div class="home-page">`.
     - Add an image tag:

       ```html
       <img src="{% static 'core/logo.svg' %}" alt="logo" class="logo" />
       ```

## Collecting Static Assets

- **Development mode (DEBUG=True):**

  - Django automatically finds `static/` folders in each app.
  - Combines their content into one “bucket” for serving static files.
  - Works only in development.

- **Production mode (DEBUG=False):**

  - Need explicit configuration and collection.

  - Define in `settings.py`:

    ```py
    STATIC_ROOT = os.path.join(BASE_DIR, "static")
    ```

  - Run:

    ```bash
    python manage.py collectstatic
    ```

    → Copies all static files from apps into `STATIC_ROOT`.

  - Must rerun on every deployment to collect latest/updated content. (We add `collectstatic` in build command.)

- **Git:**

  - Don’t commit collected static files.
  - Add `static/` to `.gitignore`.
  - Keep only **source** static files (inside each app’s `static/` folder) in Git.

## Serving Static Assets

Django cannot serve static files in production by default.

**Solution:** [WhiteNoise](https://whitenoise.readthedocs.io)

> WhiteNoise **lets Django serve static files directly**, but in larger-scale production setups, it’s still recommended to use a dedicated web server (e.g., Nginx) or CDN for better performance.  
> WhiteNoise is a lightweight alternative, suitable for simple deployments.

- Install:

  ```sh
  pipenv install whitenoise
  ```

- Add middleware in `settings.py`:

  ```py
  MIDDLEWARE = [
      # ...
      "whitenoise.middleware.WhiteNoiseMiddleware",  # must be below `SecurityMiddleware`
      # ...
  ]
  ```

  See: [Order of Middlewares](#order-of-middlewares)

With this setup, Django can serve static files in production without any extra configuration.

## Configuring Logging

Docs: [Django › Logging](https://docs.djangoproject.com/en/5.2/topics/logging)

- **Purpose of Logging**: Diagnose problems after deployment by writing events/errors to console or file.

- **Setup in Django**:

  - Define a `LOGGING` dictionary in `settings.py`.
  - Required keys:
    - `version`: always set to `1`. ([Why?](https://g.co/gemini/share/8f0ef6bfa848))
    - `disable_existing_loggers`: set to `False` (prevent Django from turning off the loggers used by third-party libraries).

- **Formatters** (how logs look):

  - We can define multiple formatters, using different str keys. (e.g. "main", "simple", "verbose", any name)
  - Define `format` string (specifying how the log should look) using [`LogRecord` attributes](https://docs.python.org/3/library/logging.html#logrecord-attributes) (e.g., `asctime`, `levelname`, `name`, `message`). Example:
    ```py
    "{asctime} ({levelname}) - {name} - {message}"
    ```
  - Can also choose `style` (how string formatting is applied):
    - `"{"` → uses `str.format()`
    - `"$"` → uses `string.Template`
  - Without formatter → shows only `message`.

- **Handlers** (decide what to do with logs):

  - `console` → `logging.StreamHandler` (writes to console).
  - `file` → `logging.FileHandler` (writes to e.g. `logs.log` using `filename`).
  - Different handlers can use different formatters.

- **Loggers** (decide which messages to capture):

  - Can target all apps (`''`) or specific ones (e.g., `playground` or `playground.views`).
  - Attach handlers to loggers.
  - E.g., capture all messages → write to both `console` & `file`.
  - Flexibility: Different apps can log differently.

- **Levels** (severity): `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`

  - Logger captures only messages >= specified level.
  - E.g.: if set to `ERROR`, only `ERROR` & `CRITICAL` logged.
  - We can also make level dynamic via env variable:
    ```py
    os.environ.get("LOG_LEVEL", "INFO")
    ```

See `settings.LOGGING` for complete code.

- **Summary**: Logging in Django = configure formatters, handlers, loggers, levels. Provides flexibility for where logs go and how they look.

## Logging

- **Logger Setup in Views**

  - Import Python’s `logging` module.
  - Use `logging.getLogger(__name__)` → creates logger named after the module (e.g., `playground.views`).
    - Use `__name__` instead of hardcoding → avoids breaking if module/app renamed.

- **Writing Log Messages**

  - Methods: `logger.debug()`, `logger.info()`, ...
  - Example:
    - Before task: `logger.info("Starting something crazy...")`
    - After: `logger.info("Success.")`
    - On failure: `logger.error("Server is busy.")`.

See code in `playground.views.test_logging()`.

- **Best Practices**

  - Use logging sparingly → too many log statements make code verbose.
  - Logs are **public** → never include sensitive info.
  - Exclude log files from Git.

## Managing Development and Production Settings

**Separate dev & prod settings**

- Storing production secrets in `settings.py` is insecure (in Git → exposed in plain text).
- DB, secret keys, debug values differ in dev vs. production.
- Solution: use **environment variables** + separate settings files.

**Restructuring settings**

1. Create a new `settings/` folder in main (`storefront`) app.

   - Move `settings.py` in it and rename to `common.py`.
   - Create `dev.py` and `prod.py`.

2. In `common.py`, update `BASE_DIR` by adding one more `.parent` to correctly point at the project's base dir.

3. In `dev.py` and `prod.py`:

   - `from .common import *` to reuse shared settings.

4. Move env-specific configs out of `common.py` to both `dev.py`, `prod.py`:

   - **Secret key** → in dev, hardcode; in prod, read from `os.environ["SECRET_KEY"]`.
   - **Debug** → True in dev, False in prod.
   - **Allowed hosts** → only required in prod (to server domain/IP).
   - **Database config** → dev: Postgres localhost; prod: DB connection string.
   - **Installed apps** → keep in common; dev: append `debug_toolbar`, `silk`
   - **Middlewares** → keep in common; dev: insert `DebugToolbar` at 0, `ForceDebugToolbar` at 1, append `Silky` (See: [Order of Middlewares](/Notes/Part%203/7.%20Preparing%20for%20Production.md#order-of-middlewares))

5. For now, all other configs stay in `common.py`.

**Updating references**

- Modify files that reference `DJANGO_SETTINGS_MODULE`:

  In `manage.py`, `wsgi.py`, `asgi.py`, `pytest.ini`, `celery.py`:

  `storefront.settings` → `storefront.settings.dev`

- In production, we'd just add an env var: `'DJANGO_SETTINGS_MODULE' = 'storefront.settings.prod'`. This way, we're set for both dev & prod. ✓

  (`os.environ.setdefault` sets a default val for an env var **if that var is not already present in the env**.)

## Serving the Application with Gunicorn

Django’s built-in dev server:

- Auto-reloads on code changes.
- Only meant for development (not fast/robust enough for production).

**Gunicorn (Green Unicorn)**

- A production-grade WSGI HTTP server.
- Install with `pipenv install gunicorn`.
- To run: `python -m gunicorn storefront.wsgi` (instead of `gunicorn storefront.wsgi`; [Why?](https://g.co/gemini/share/f5dad9203d53) TLDR: It's safer (more reliable))
  - `storefront.wsgi` is the entry point (from `wsgi.py` file in the project folder).
- `wsgi.py`:
  - Sets `DJANGO_SETTINGS_MODULE` (e.g., `storefront.settings.dev`).
  - Calls `get_wsgi_application()` to return an application instance.

**Django Development Server vs Production Server**

- Gunicorn starts a web server on `localhost:8000` (similar to Django dev server).
- Faster and more robust than Django’s dev server.
- Unlike dev server, Gunicorn **does not auto-reload** on code changes. Must restart manually.
- For dev → we would keep using Django’s dev server.
- For prod → use Gunicorn.

---

## Order of Middlewares

> Researched by me.

**Django out of the box:**

```py
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]
```

- Docs - [Middleware ordering](https://docs.djangoproject.com/en/5.2/ref/middleware/#middleware-ordering)

**WhiteNoise**

> "add WhiteNoise above all other middleware apart from Django’s SecurityMiddleware" - [Docs](https://whitenoise.readthedocs.io/en/stable/#quickstart-for-django-apps)

```py
MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]
```

**CORS**

> "`CorsMiddleware` should be placed as high as possible, especially before any middleware that can generate responses such as Django's `CommonMiddleware` or Whitenoise's `WhiteNoiseMiddleware`. If it is not before, it will not be able to add the CORS headers to these responses." - [GitHub](https://github.com/adamchainz/django-cors-headers?tab=readme-ov-file#setup)

So, `Cors` can go either before or just after `Security`.

But:

> `SecurityMiddleware` can return a response directly. It does this mainly to enforce HTTPS by issuing a permanent redirect when `SECURE_SSL_REDIRECT = True` is set and an insecure (`http://`) request is received. - [Gemini](https://g.co/gemini/share/2892b7afe04f)

So, `Cors` must be before `Security`.

> If `SecurityMiddleware` is first, its redirect response will be sent to the browser **without** CORS headers, causing an immediate CORS error. `CorsMiddleware` must be placed first so it can add the required headers to _any_ response generated by the middleware below it, including redirects. - [Gemini](https://g.co/gemini/share/959054a000a8)

```py
MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]
```

**Silk**

There's no mandate on where to put Silk. I'm putting it in absolute end with the reasoning that I want to **profile just my code** (the view). (As we know, after the middlewares, request passes on to the view. - [Docs](https://docs.djangoproject.com/en/dev/topics/http/middleware/#middleware-order-and-layering))

```py
MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "silk.middleware.SilkyMiddleware",
]
```

**Debug Toolbar**

> "You should include the Debug Toolbar middleware as early as possible in the list. However, it must come after any other middleware that encodes the response’s content, such as `GZipMiddleware`." - [Docs](https://django-debug-toolbar.readthedocs.io/en/latest/installation.html#add-the-middleware)

And `ForceDebugToolbar`:

- After `DebugToolbar` - [GitHub](https://github.com/barseghyanartur/django-debug-toolbar-force/?tab=readme-ov-file#installation)

```py
MIDDLEWARE = [
    "debug_toolbar.middleware.DebugToolbarMiddleware",
    "debug_toolbar_force.middleware.ForceDebugToolbarMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "silk.middleware.SilkyMiddleware",
]
```
