## Setting up a Fake SMTP Server

- **SMTP** = Simple Mail Transfer Protocol → protocol/software to send & receive emails.

- **Real SMTP servers** are used in production (often paid).

- For **development**, use a **fake SMTP server** → recommended: **[smtp4dev](https://github.com/rnwood/smtp4dev)**.

- Purpose: test email-sending in dev environment without needing a real mail service.

### Installation (with Docker)

> Out of [installation options](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md), this is the most recommended one. (Simple, reliable, professional-grade.)

1. Install/run [Docker Desktop](https://www.docker.com/products/docker-desktop).

   > Docker is a fantastic tool for creating consistent and isolated development environments. If you plan to work in a team, this is the best long-term option. It keeps `smtp4dev` separate from the rest of your system. - [Gemini](https://g.co/gemini/share/8cd860068c6e)

2. Run:

   ([How to run smtp4dev in Docker](https://github.com/rnwood/smtp4dev/blob/master/docs/Installation.md#how-to-run-smtp4dev-in-docker))

   ```sh
   docker run --rm -it -p 5000:80 -p 2525:25 rnwood/smtp4dev
   ```

   (Understand the cmd: [Gemini](https://g.co/gemini/share/0db7331ae8c3))

   With this, SMTP server will listen on port `2525` (configure `EMAIL_PORT` in Django settings to use this).

We get an **Admin panel** / Web UI: available at [localhost:5000](http://localhost:5000) → acts like a mail client (shows test emails sent by app).

### Port Not Available

On MacOS, `5000` is not available due to [AirPlay Receiver](https://developer.apple.com/forums/thread/682332).

How to see what's using a port number:

```sh
lsof -i :5000
```

**SOLUTION: Just use a different port number. (e.g. `3000`)**

## Configuring the Email Backend

- **Email backend** = engine responsible for sending emails.

- Django provides multiple backends:

  - **SMTP backend** (default; uses SMTP server).
  - **Console backend** (prints emails to terminal).
  - **File backend** (writes emails to a file).
  - **In-memory backend** (stores emails in local memory).
  - **Dummy backend** (does nothing).

- **SMTP backend** is most commonly used.

- Configuration is set in **settings.py**:

  - `EMAIL_BACKEND` → backend module/class (default: `django.core.mail.backends.smtp.EmailBackend`).

  - `EMAIL_HOST` → SMTP server address (e.g., `localhost`).

  - `EMAIL_HOST_USER` → username (leave empty for fake SMTP).

  - `EMAIL_HOST_PASSWORD` → password (leave empty for fake SMTP).

    - **In production**: we don’t store passwords in settings, but load via **environment variables**.

  - `EMAIL_PORT` → default: `25`; fake SMTP often runs on `2525`.

  - `DEFAULT_FROM_EMAIL` → optional, id from which mails would be sent (e.g., `general@samyakstore.com`), can be overridden in mail functions (`send_mail()`).

Django Docs: [Email backends](https://docs.djangoproject.com/en/5.2/topics/email/#email-backends)

## Sending Emails

- **Mail Functions**

  In `django.core.mail`, we have:

  - `send_mail` – opens a new connection for each email.
  - `send_mass_mail` – uses a single connection for multiple emails (better for performance).
  - `mail_admins` – sends email to site admins.
  - `mail_managers` – similar, but for managers.

- **Using `send_mail`**

  - Syntax: `send_mail(subject, message, from_email, recipient_list, ...)`
  - `from_email` to override the default configured sender `settings.DEFAULT_FROM_EMAIL`.
  - Example:
    ```py
    send_mail(
        subject="Testing",
        message="Hello there!",
        from_email=None,
        recipient_list=["customer@gmail.com"],
    )
    ```
  - We can also send html message using `html_message` param, e.g., `html_message="<h1>Hello there!</h1>"`

- **Plain Text vs HTML**

  - `message` argument = plain text.
  - `html_message` argument = HTML content.
  - Emails can contain both versions (multipart) → client chooses what to render.
  - Most modern clients support HTML, but fallback (`message`) is for edge cases.

- **Security (Header Injection Protection)**

  - Wrap `send_mail` in `try/except`.
  - Import `BadHeaderError` and catch it to avoid email header injection attacks.
  - Technically it’s raised when the email headers are invalid, not just from “attackers” (though that’s a common cause).

- **Testing Email**

  - Use `smtp4dev` (running on [localhost:3000](http://localhost:3000)) to inspect outgoing test emails.

- **Using `mail_admins`**

  ```py
  mail_admins(subject="Testing", message="Hello admin!")
  ```

  Similar to `send_mail`, but:

  - Mail sender is `root@localhost` by default, and `from_email` override option is not available.

  - Instead of `recipient_list`, mail is sent to `settings.ADMINS`:

    ```py
    ADMINS = [("Samyak", "samyak65400@gmail.com"),]
    ```

## Attaching Files

- **`EmailMessage` class**

  - All helper functions (`send_mail`, `mail_admins`, etc.) internally use it.
  - Use an `EmailMessage` object for more control.
  - Accepts: `subject`, `body`, `to`, `cc`, etc.

- **Attaching Files**

  - Use `.attach_file(path)` method.
  - Path should be relative to the project directory.

- **Sending Email**

  - After attaching, call `.send()` on the message object.

> See code in `playground.views.test_mail`.

So basically, we use `EmailMessage` over `send_mail` for extra control like:

- File attachments
- `cc`/`bcc` support
- More customization

## Sending Templated Emails

Using `send_mail` or `EmailMessage` is not practical for long/dynamic emails (hard to maintain).

**Solution: `django-templated-mail`**

- A thin wrapper around Django’s email system.
- Allows defining emails as **templates** (subject, text body, HTML body).
- Uses Django html templates and template engine. (See the code.)

Docs: [django-templated-mail.readthedocs.io](https://django-templated-mail.readthedocs.io)

```sh
pipenv install django-templated-mail
```

Now, since mail templates are templates, we can add a new dir `mails` in the `templates` dir, and use that for adding our mails (mail templates).

**Template Structure**

- Use `{% block subject %} ... {% endblock %}` → email subject.
- `{% block text_body %} ... {% endblock %}` → plain text body (optional).
- `{% block html_body %} ... {% endblock %}` → HTML body (optional).
- Use Django template syntax (`{{ variable }}`) for dynamic values (e.g., `{{ name }}`).

**Using in Views**

```py
from templated_mail.mail import BaseEmailMessage

BaseEmailMessage(context={"name": "Samyak"}, template_name="playground/mails/hello.html").send(to=["customer@gmail.com"])
```

**Best Practices:** Always **namespace templates** inside category-specific folders to increase clarity.
