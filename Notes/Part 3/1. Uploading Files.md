## Managing Media Files

**Media vs Static**

- _Static_: app’s own assets (CSS, JS, images).
- _Media_: user-uploaded files.

### Setup Steps

1. Create a `media` folder in project root.
2. In `settings.py`:

   - `MEDIA_URL = 'media/'` (endpoint for accessing uploads).
   - `MEDIA_ROOT = os.path.join(BASE_DIR, 'media')` (location in filesystem).

### Serve Media in Development

- In `urls.py`:

  ```py
  from django.conf import settings
  from django.conf.urls.static import static

  urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
  ```

- `static` serves media files only when `DEBUG=True`.

### Test

- Place a sample file (e.g., `car.jpg`) in `media`.
- Access via `http://localhost:8000/media/car.jpg`.

### Important

- This method is only for **development**.
- Production requires a different strategy (covered later).

## Adding Images to Products

**Requirement**: Each product can have 0 or more images → add a one-to-many relationship.

### Model Setup

Create a new model `ProductImage` with fields:

- `product = models.ForeignKey(Product, on_delete=models.CASCADE)`

  - Ensure images are deleted with product.

- `image = models.ImageField(upload_to='store/images')`
  - Validates uploaded files are images.
  - Provides extra properties (`width`, `height`).
  - Stores file path in DB, file itself in filesystem under `MEDIA_ROOT/store/images/`.

### Image vs File Field

- `ImageField`: for image uploads (validation, image properties).
- `FileField`: for generic file uploads (docs, PDFs, etc.).

### Storage

- Images are **not stored in DB** → only file paths saved.
- Improves performance and avoids large DB size.

### Dependencies

Required for `ImageField` (else error):

```sh
pipenv install pillow
```

### Migration

Run `makemigrations` & `migrate`.

## Building an API to Upload Images

- **Goal:** Implement nested endpoint `/product/<id>/images/<id>` for product images.
- **API building blocks needed:** Serializer > ViewSet > Router

### Serializer (`ProductImageSerializer`)

- `Meta`: `model = ProductImage`, `fields = ['id', 'image']`.
- **Exclude `product_id`** since it's already in the URL.

### ViewSet (`ProductImageViewSet`)

- `serializer_class = ProductImageSerializer`

- Override `get_queryset` to filter images by `product_pk` from URL:

  ```py
  def get_queryset(self):
      return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])
  ```

### Router

Register nested route:

```py
router.register('images', ProductImageViewSet, basename='product-images')
```

### Error Fix

- **Error:** `column product_id cannot be null`.
- **Cause:** Only `image` was sent in POST body, not `product_id`.
- **Fix:** Extract product_id from URL (via context) instead of expecting it in request body.

In `ProductImageViewSet`, override `get_serializer_context` to pass `product_id` to serializer:

```py
def get_serializer_context(self):
    return {'product_id': self.kwargs['product_pk']}
```

And in `ProductImageSerializer`, override `create` to attach product_id from context:

```py
def create(self, validated_data):
    return ProductImage.objects.create(product_id=self.context['product_id'], **validated_data)
```

> **NOTE THAT THIS WHOLE SECTION WAS EXACTLY THE SAME AS [Building the Reviews API](https://github.com/samyak1409/ultimate-django/blob/main/Notes/Part%202/2.%20Advanced%20API%20Concepts.md#building-the-reviews-api--nested-routers).**

### Result

- Now, with everything in place, we can upload images using `POST /store/products/1/images`
- Uploaded images stored in `MEDIA_ROOT/store/images/`.
- If duplicate filename, Django automatically appends unique suffix (to prevent overwrite).

## Returning Images from the API

**Goal:** Include product image urls directly in the **products endpoint response** (avoid multiple API calls).

### Implementation

**Modify `ProductSerializer`:**

- Add `productimage_set` field → use `ProductImageSerializer`.
- Set `many=True` (since product can have multiple images).
- Set `read_only=True` (to not create images via product POST).

**Result:**

- Products now return an `images` property (list of images with ID + URL).

### Fix N+1

Without optimization → Django runs **duplicate queries** (N+1 problem).

In `ProductViewSet`, use:

```py
queryset = Product.objects.prefetch_related('productimage_set')
```

This reduces DB hits.

## Validating Uploaded Files

**ImageField** automatically validates file type (via **Pillow**).

- Rejects invalid images (e.g., `.pdf`, `.doc`).
- Pillow must be installed.

### File Size Validation

- We don't have built-in validator for file size.

- Custom validator needed:

  1. Create `validators.py` in the app.

  2. Define `validate_product_image_size(image)`.

     - Set `MAX_PRODUCT_IMAGE_SIZE_KB`.
     - If `file.size > MAX_PRODUCT_IMAGE_SIZE_KB * 1024` → raise `ValidationError('error message...')`.

  3. Apply validator in model field, add param:

     ```py
     validators=[validate_product_image_size]
     ```

- Test upload: error message should be shown.

### File Extension Validation

- Useful with `FileField` (not `ImageField`).

- Django provides `FileExtensionValidator` (`django.core.validators`).

  - E.g.:

    ```py
    validators=[FileExtensionValidator(allowed_extensions=['pdf'])]
    ```

  - Uploading `.txt` → error: `"File extension 'txt' is not allowed. Allowed extensions are: pdf."`

## Setting Up the Client App

- Mosh has used a **basic JavaScript client project** for uploading product images.

  > But I converted that to a single HTML file using Gemini, keeping all functionality exactly the same.  
  > (So that Node.js, etc. are not required.)

- Purpose: Show how client + server integration works.

- Open the html file in chrome, we can see a simple page with an upload input.

## Enabling CORS

**Problem**:

Uploading image from client (local file or port `8001`) to backend (port `8000`) fails due to **CORS (Cross-Origin Resource Sharing)** restrictions.

**Reason**:

> "Adding CORS headers allows your resources to be accessed on other domains."  
> \- [`django-cors-headers`@github](https://github.com/adamchainz/django-cors-headers?tab=readme-ov-file#about-cors)

And we've not allowed any domain to access our resources.

**Steps to fix**:

1. Install: `pipenv install django-cors-headers`.

2. Add `"corsheaders"` to `INSTALLED_APPS`.

3. Add middleware: `"corsheaders.middleware.CorsMiddleware"` **at the top** of `MIDDLEWARE`.

4. [Configure allowed origins](https://github.com/adamchainz/django-cors-headers?tab=readme-ov-file#configuration):

   ```py
   CORS_ALLOWED_ORIGINS = ["null"]  # allow requests from local files (file://...)
   ```

   - Can also use regex (`CORS_ALLOWED_ORIGIN_REGEXES`).
   - Allow-all (`CORS_ALLOW_ALL_ORIGINS = True`) **not recommended**.

**How CORS works under the hood**:

On upload, browser sends **two requests**:

1. **OPTIONS (preflight)** request → server responds where one of the header is `Access-Control-Allow-Origin`.

   (`django-cors-headers` inserts the correct headers into responses.)

   If the `Access-Control-Allow-Origin` header doesn't contain client origin, then following `POST` request fails.

2. **POST** request (actual upload).

## Managing Images in the Admin

**Goal**: Manage product images directly from the Django admin interface (similar to tags).

**Current `Product` Admin Classes** (Just to revise):

- `store` app → reusable admin (`ProductAdmin`).
- `core` app → project-specific admin (extends `ProductCustomAdmin`); (containing things from different app)

### Steps

1. **Define inline for images**

   ```py
   class ProductImageInline(admin.TabularInline):
       model = ProductImage
   ```

   - Place in `store` app (since `ProductImage` belongs there).

2. **Register inline**

   - Add `ProductImageInline` to `inlines` in `ProductAdmin`.
   - **IMP:** Also add it in `core` app’s `ProductCustomAdmin`, since it overrides `inlines`. (Then why do we need in `ProductAdmin`? Think.)

> With that in place, now we can see product images (urls) in inline table. But, we can also set to show (render) the images there itself.

3. **Show thumbnails in admin**

   - Add `readonly_fields = ["thumbnail"]` to `ProductImageInline`.
   - Define `thumbnail(self, instance)` method:

     - If image exists → return `f'<img src="{instance.image.url}" height=64>'` using `format_html()` (to actually render instead of showing the html text).

> With that in place, now everything works like required!

> But, as we know it's not a good practice to add css inline, we should instead use dedicated css file.

4. **CSS file**

   - Create `static/store/styles.css` inside `store` app.
   - Add `.thumbnail {height: 64px;}`.
   - Remove `height=64`, add `class="thumbnail"`.

   We need to explicitly **load** CSS in admin page:

   - In `ProductAdmin`, define `Media` class:

     ```py
     class Media:
         css = {"all": ["store/styles.css"]}
     ```

   - `"all"` means CSS applies everywhere (`screen` + `print`).

   **FAQ:** Why do we need another "store" dir when we're already in the "store" app?

   - Because, we've option to define one app's static file in another app.
