## Managing Media Files

**Media vs Static**

- _Static_: app’s own assets (CSS, JS, images).
- _Media_: user-uploaded files.

### Setup Steps

1. Create a `media` folder in project root.
2. In `settings.py`:

   - `MEDIA_URL = 'media/'` (endpoint for accessing uploads).
   - `MEDIA_ROOT = os.path.join(BASE_DIR, 'media')` (location in filesystem).

### Serve Media in Development

- In `urls.py`:

  ```py
  from django.conf import settings
  from django.conf.urls.static import static

  urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
  ```

- `static` serves media files only when `DEBUG=True`.

- Important: This method is only for **development**. Production requires a different strategy (covered later).

### Test

- Place a sample file (e.g., `car.jpg`) in `media`.
- Access via [`/media/car.jpg`](http://localhost:8000/media/car.jpg).

## Adding Images to Products

**Requirement**: Each product can have 0 or more images → add a one-to-many relationship.

### Model Setup

Create a new model `ProductImage` with fields:

- `product = models.ForeignKey(Product, on_delete=models.CASCADE)`

  - Ensure images are deleted with product.

- `image = models.ImageField(upload_to='store/images')`

  - `ImageField` validates uploaded files are images.
  - Provides extra properties (`width`, `height`).
  - Note that **file path** is stored in DB, file itself in filesystem under `MEDIA_ROOT/store/images/`.

### Image vs File Field

- `ImageField`: for image uploads (validation, image properties).
- `FileField`: for generic file uploads (docs, PDFs, etc.).

### Storage

- Images are **not stored in DB** → only file paths saved.
- Improves performance and avoids large DB size.

### Dependencies

Required for `ImageField` (else error):

```sh
pipenv install pillow
```

### Migration

Run `makemigrations` & `migrate`.

## Building an API to Upload Images

- **Goal:** Implement nested endpoint `/product/<id>/images/<id>` for product images.
- **API building blocks:** Serializer > ViewSet > Router

### Serializer (`ProductImageSerializer`)

- `Meta`: `model = ProductImage`, `fields = ['id', 'image']`.
- **Not including `product`** since it's already in the URL.

### ViewSet (`ProductImageViewSet`)

- `serializer_class = ProductImageSerializer`

- Override `get_queryset` to filter images by `product_pk` from URL:

  ```py
  def get_queryset(self):
      return ProductImage.objects.filter(product_id=self.kwargs['product_pk'])
  ```

### Router

Register nested route:

```py
product_router.register('images', ProductImageViewSet, basename='product-images')
```

### Error Fix

- **Error:** `column product_id cannot be null`.
- **Cause:** Only `image` was sent in POST body, not `product_id`.
- **Fix:** Extract product_id from URL (via context) instead of expecting it in request body.

In `ProductImageViewSet`, override `get_serializer_context` to pass `product_id` to serializer:

```py
def get_serializer_context(self):
    return {'product_id': self.kwargs['product_pk']}
```

And in `ProductImageSerializer`, override `create` to attach product_id from context:

```py
def create(self, validated_data):
    # return ProductImage.objects.create(product_id=self.context['product_id'], **validated_data)
    return super().create(validated_data | {"product_id": self.context["product_id"]})
```

> **NOTE THAT THIS WHOLE SECTION WAS EXACTLY THE SAME AS [Building the Reviews API](/Notes/Part%202/2.%20Advanced%20API%20Concepts.md#building-the-reviews-api--nested-routers).**

### Result

- Now, with everything in place, we can upload images using `POST /store/products/<id>/images`
- Uploaded images stored in `MEDIA_ROOT/store/images/`.
- If duplicate filename, Django automatically appends unique suffix (to prevent overwrite).

## Returning Images from the API

**Goal:** Include product image urls directly in the **products endpoint response** (avoid multiple API calls).

### Implementation

**Modify `ProductSerializer`:**

- Add `productimage_set` field → use `ProductImageSerializer`.
- Set `many=True` (since product can have multiple images).
- Set `read_only=True` (to not create images via product POST).

**Result:**

- Products now return an `images` property (list of images with ID + URL).

- By default:
  - On `images` endpoint (`/store/products/<id>/images`), only path is showing (`"image": "/media/store/images/<name>"`).
  - But on `products` endpoint (`/store/products`), full url (`"image": "http://127.0.0.1:8000/media/store/images/<name>"`).

### Fix N+1

Without optimization → Django runs **extra queries** (N+1 problem).

In `ProductViewSet`, use:

```py
queryset = Product.objects.prefetch_related('productimage_set')
```

##

**TODO:**

Delete product image from filesystem when:

1. The image is deleted using `DELETE` HTTP request. (Currently everything works, just the image on the filesystem stays there only.)
2. Since deleting a product deletes all its images as well, verify if it is deleting from the filesystem as well or not, now that we've implemented `1.`.
3. Delete previous image when a new image is uploaded using `PUT`.

[Mosh didn't.]

## Validating Uploaded Files

**ImageField** automatically validates file type (via **Pillow**).

- Rejects invalid images (e.g., `.pdf`, `.doc`).
- Pillow must be installed.

### File Size Validation

- We don't have built-in validator for file size.

- Custom validator needed:

  1. Create `validators.py` in the app.

  2. Define `validate_product_image_size(image)`.

     - Set `MAX_PRODUCT_IMAGE_SIZE_KB`.
     - If `file.size > MAX_PRODUCT_IMAGE_SIZE_KB * 1024` → raise `ValidationError('Error message...')`.

  3. Apply validator in model field, add param:

     ```py
     validators=[validate_product_image_size]
     ```

- After any model changes, don't forget to run `makemigrations` & `migrate`.

- Test upload: error message should be shown.

### File Extension Validation

- Useful with `FileField` (not `ImageField`).

- Django provides `FileExtensionValidator` (`django.core.validators`).

  - E.g.:

    ```py
    validators=[FileExtensionValidator(allowed_extensions=['pdf'])]
    ```

  - Uploading `.txt` → error: `"File extension 'txt' is not allowed. Allowed extensions are: pdf."`

## Setting Up the Client App

- Mosh has used a **basic JavaScript client project** for uploading product images.

  > But I converted that to a single HTML file <!-- using Gemini -->, keeping all functionality exactly the same.  
  > (So that Node.js, etc. are not required.)

- Purpose: Show how client + server integration works.

- Open the html file in chrome, we can see a simple page with an upload input.

## Enabling CORS

**Problem**:

Uploading image from client (local file or port `8001`) to backend (port `8000`) fails due to **CORS (Cross-Origin Resource Sharing)** restrictions.

**Reason**:

> "Adding CORS headers allows your resources to be accessed on other domains."  
> \- [`django-cors-headers`@github](https://github.com/adamchainz/django-cors-headers?tab=readme-ov-file#about-cors)

And we've not allowed any domain to access our resources.

**Steps to fix**:

1. Install: `pipenv install django-cors-headers`.

2. Add `"corsheaders"` to `INSTALLED_APPS`.

3. Add middleware: `"corsheaders.middleware.CorsMiddleware"` **at the top**. (See: [Order of Middlewares](/Notes/Part%203/7.%20Preparing%20for%20Production.md#order-of-middlewares))

4. [Configure allowed origins](https://github.com/adamchainz/django-cors-headers?tab=readme-ov-file#configuration):

   ```py
   CORS_ALLOWED_ORIGINS = ["null"]  # allow requests from local files (file://...)
   ```

   - Can also use regex (`CORS_ALLOWED_ORIGIN_REGEXES`).
   - Allow-all (`CORS_ALLOW_ALL_ORIGINS = True`) **not recommended**.

**How CORS works under the hood**:

On upload, browser sends **two requests**:

1. **OPTIONS (preflight)** request → server responds where one of the header is `Access-Control-Allow-Origin`.

   (`django-cors-headers` inserts the correct headers into responses.)

   If the `Access-Control-Allow-Origin` header doesn't contain client origin, then following `POST` request fails.

2. **POST** request (actual upload).

## Managing Images in the Admin

**Goal**: Manage product images directly from the Django admin interface (similar to tags).

**Current `Product` Admin Classes** (Just to revise):

- `store` app → reusable admin (`ProductAdmin`).
- `core` app → project-specific admin (extends `ProductCustomAdmin`); (containing things from different app)

### Steps

1. **Define inline for images**

   ```py
   class ProductImageInline(admin.TabularInline):
       model = ProductImage
   ```

   - Place in `store` app (since `ProductImage` belongs there).

2. **Register inline**

   - Add `ProductImageInline` to `inlines` in `ProductAdmin`.
   - ~~Also add it in `core` app’s `ProductCustomAdmin`.~~ - Again, wrong by Mosh. **Violates: DRY Principle**
   - Correct way: Override: `inlines = list(ProductAdmin.inlines) + [TaggedItemInline]` (Confirmed from [Gemini](https://g.co/gemini/share/368158fbab70) (Read TLDRs))

> With that in place, now we can see product images (urls) in inline table. But, we can also set to show (render) the images there itself.

3. **Show thumbnails in admin**

   - Add `readonly_fields = ["thumbnail"]` to `ProductImageInline`.
   - Define `thumbnail(self, instance)` method:

     - If image exists → return `f'<img src="{instance.image.url}" height=64>'` using `format_html()` (to actually render instead of showing the html text).

> With that in place, now everything works like required!

> But, as we know it's not a good practice to add CSS inline, we should instead use dedicated CSS file.

4. **CSS file**

   - Create `static/store/styles.css` inside `store` app.
   - Add `.thumbnail {height: 64px;}`.
   - Remove `height=64`, add `class="thumbnail"`.

   We need to explicitly **load** CSS in admin page:

   - In `ProductAdmin`, define `Media` class:

     ```py
     class Media:
         css = {"all": ["store/styles.css"]}
     ```

   - `"all"` means CSS applies everywhere (`screen` + `print`).

> **FAQ:** Why do we need another "store" dir when we're already in the "store" app?
>
> - The `manage.py collectstatic` command copies all static files from all your apps into a single folder for deployment (`STATIC_ROOT`).
> - Without namespacing, files with the same name (e.g., `styles.css`) from different apps will overwrite each other during this process.
> - Creating an extra subdirectory with the app's name (e.g., `static/store/`) solves this by ensuring every file has a unique path.
>
> \- [Gemini](https://g.co/gemini/share/73e20a46eaea)
