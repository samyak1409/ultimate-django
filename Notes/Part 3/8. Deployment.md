## Hosting Options

**Two main options:**

1. **Virtual Private Server (VPS):**

   - Cheaper.
   - Requires more setup and system administration skills.

2. **Platform as a Service (PaaS):**

   - Easier to use, managed environment.
   - Examples: Heroku, DigitalOcean App Platform, Microsoft Azure, Google Cloud, ...

**Recommendation:**

- VPS only if you have strong server management skills.
- PaaS is better for most developers due to simplicity and documentation.

> NOTE:  
> Mosh has used Heroku, but it's free tier is dead now.  
> That's why I used [Render](https://render.com/pricing), [Koyeb](https://www.koyeb.com/pricing) for [Django Blog](https://github.com/samyak1409/django) project.

## Adding Project to Git

Introduces Git for source control, covering repo init, staging, committing, log history, and the concept of snapshots.

## Getting Started with Heroku

Shows how to set up Heroku for deployment: create account, install Heroku CLI, verify, and log in.

## Creating a Heroku App

Covers creating a Heroku app, explains local vs remote Git repos, adds the app domain (e.g. `"moshbuy-prod.herokuapp.com"`) to `ALLOWED_HOSTS` in `settings/prod.py`.

## Setting Environment Variables

Explains generating Django `SECRET_KEY` and setting it on Heroku, along with setting `DJANGO_SETTINGS_MODULE` to production settings (as discussed in `7. Preparing for Production > Managing Development and Production Settings`).

Generate secret key:

- Using `django`:

  ```sh
  python -c "from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())"
  ```

  OR

- Using `secrets`:

  ```sh
  python3 -c "import secrets; print(secrets.token_urlsafe(50))"
  ```

## Creating a Procfile

- **Purpose**

  - A special file (must be spelled exactly as **`Procfile`**, capital `P`, no extension).
  - Tells the hosting/deployment platform how to start and manage the application processes.

- **Release process (optional)**

  - `release: python manage.py migrate`
  - Runs migrations automatically every time the app is deployed.
  - Some prefer manual migrations — if so, skip this line.

- **Web process**

  - `web: gunicorn storefront.wsgi`
  - Uses **Gunicorn** as the production server to run the Django app.

- **Worker process**

  - `worker: celery -A storefront worker`
  - Runs Celery tasks in the background (same command as we used in development).

- **What Procfile achieves**

  - Automates migrations on deploy (if desired).
  - Ensures both the web app and background worker start properly on the platform.
  - Clearly defines which processes the platform should manage after deployment.

## Provisioning a ~~MySQL~~ Database

1. Get DB URL.

2. Set `DATABASE_URL` env var.

3. Configure Django to use the database:

   - Install:

   ```sh
   pipenv install dj-database-url
   ```

   - In prod settings file:

   ```py
   DATABASES = {"default": dj_database_url.config()}
   ```

   `config`: "Returns configured DATABASE dictionary from DATABASE_URL."

## Provisioning a Redis Instance

- **Redis usage in our project**

  - Used as **Celery message broker** (DB `1`) and **cache** (DB `2`), that's two instances.
  - Using two instances on production would cost us double.
  - Using a single Redis instance for both broker and cache is fine, as Redis is a **key-value store**, not relational.

1. Get Redis URL.

2. Set `REDIS_URL` env var.

3. Use `REDIS_URL` in django prod setting for both Celery broker and cache.

   - Move `CELERY_BROKER_URL` & `CACHES` settings from `common.py` to `dev.py` & `prod.py` files for clarity.

## Provisioning an SMTP Server

- **SMTP server setup**

  - Find a free option. (Mosh has used Mailgun)
  - Get values (host, port, user, password), and set env vars.

- **Django configuration**

  - Move email settings from common config to **dev** and **prod** files.
  - In prod: read from env vars.

- **Outcome** Production environment is ready to send emails via the chosen SMTP server.

## Deploying the Application

- **Deployment**

  - Push to Heroku remote: `git push heroku main`
  - Heroku builds app: detects Python, installs dependencies, runs collectstatic, and applies migrations.
  - Now, app accessible via Heroku domain.

- **Other useful commands**

  - `heroku run bash` → open shell in production, list files (`ls`).
  - `heroku run python manage.py createsuperuser` → create admin user.
  - `heroku open` → open app in browser.

## Populating the Database

- **Custom seed command**

  - In the very start of `Part 3`, we added `store/management/commands/seed_db.py`, a custom command (`seed_db`) to populate DB.
  - Run: `heroku run python manage.py seed_db`
  - Check results: Refresh browser → data populated.

- **Alternative: DataGrip**

  - Get DB connection string: `heroku config:get DATABASE_URL`
  - Open DataGrip → create new data source.
  - Choose **“URL only”** mode → paste connection string.
  - Keep `jdbc:` prefix, then replace default URL with copied MySQL string.
  - Test & connect → see tables and run custom queries.

## Dockerizing the App

> [Not doing this because Mosh has not explained how **exactly** everything works.]
>
> [The Ultimate Docker Course](https://codewithmosh.com/p/the-ultimate-docker-course), [Docker Tutorial for Beginners](https://youtu.be/pTFZFxd4hOI)

- **Why Docker?**

  - Eliminates need to manually install/run MySQL, Redis, Celery, SMTP, etc.
  - Ensures consistent versions/environments across dev & prod.
  - New developers avoid dependency/version mismatch.

- **Setup**

  - Provided `docker/` folder → move files to project root.
  - `docker-compose.yml` defines all services:
    - `web` (Django app)
    - `postgres`
    - `redis`
    - `smtp4dev`
    - celery, flower, etc.
  - Each service runs in its own **container** (isolated VM-like environment).

- **Configuration changes (`dev.py`)**

  - Change DB host → `localhost`/`127.0.0.1` → `mysql`.
  - Change Redis host → `localhost`/`127.0.0.1` → `redis`.
  - Change email host → `smtp4dev`.
  - Debug toolbar fix → force-enable with `DEBUG_TOOLBAR_CONFIG = {"SHOW_TOOLBAR_CALLBACK": lambda request: True}`.

- **Stop local services:** Stop system MySQL/Redis/etc. to free ports before using Docker.

- **Run with Docker Compose**

  - `docker compose up --build` → build & run all services (foreground logs).
  - `docker compose up -d --build` → run in background.
  - `docker compose logs <service>` → view logs (e.g. `web`, `tests`).
  - `docker compose logs -f <service>` → follow live logs.

- **Database & admin setup:** Run commands inside container:

  - `docker compose run web bash` → open shell in web container.
  - `docker compose run web python manage.py seed_db` → seed database.
  - `docker compose run web python manage.py createsuperuser` → create admin.

- **Stopping services:** `docker compose down` → stop all services.

- **Outcome:** One-command startup, consistent environment, ability to inspect containers/logs.

---

> NOTE: Mosh has not added a media hosting service, and mapped `MEDIA_URL` via `static()`. This results in no access to media (product images) on production site.
